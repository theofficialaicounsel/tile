<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ai-nspired</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
<style>
  :root { --card-min-height: 220px; }
  body { font-family: system-ui, sans-serif; margin: 0; padding: 0; background: #f5f5f5; overflow-x: hidden; }

  #selectionBar {
    position: fixed; top: 0; left: 0; right: 0;
    background: #fff; border-bottom: 1px solid #ddd;
    padding: 12px; z-index: 1000; display: none;
    justify-content: space-between; align-items: center;
    font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  #selectionBar.active { display: flex; }
  #mergeSelected { background: #0066ff; color: white; border: none; padding: 8px 16px; border-radius: 8px; }

  .fullscreen-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.8); display: none; z-index: 10000;
    backdrop-filter: blur(5px); align-items: center; justify-content: center;
  }
  .fullscreen-overlay.active { display: flex; }
  .fullscreen-card { width: 95%; max-width: 1000px; height: 95vh; background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); perspective: 2000px; }
  .fullscreen-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
  .fullscreen-overlay.flipped .fullscreen-inner { transform: rotateY(180deg); }
  .fullscreen-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 20px; display: flex; flex-direction: column; overflow: hidden; }
  .fullscreen-front, .fullscreen-back { background: #fff; }
  .fullscreen-header { padding: 12px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(to right, #f8f9fa, #ffffff); }
  .fullscreen-close, .fullscreen-flip, .fullscreen-split { background: none; border: none; font-size: 20px; cursor: pointer; opacity: 0.6; padding: 8px; border-radius: 6px; }
  .fullscreen-close:hover, .fullscreen-flip:hover, .fullscreen-split:hover { opacity: 1; background: rgba(0,0,0,0.05); }
  .fullscreen-content { flex: 1; padding: 25px; overflow-y: auto; font-size: 16px; line-height: 1.6; outline: none; min-height: 0; }
  .fullscreen-content[contenteditable="true"] { background: rgba(0,102,255,0.03); border-radius: 8px; }
  .fullscreen-title { font-weight: bold; color: #333; font-size: 18px; }

  .streaming-indicator { text-align: center; color: #666; padding: 20px; font-size: 16px; }
  .streaming-cursor { display: inline-block; width: 3px; height: 1em; background: currentColor; animation: blink 1s infinite; margin-left: 2px; }
  @keyframes blink { 50% { opacity: 0; } }

  #grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
    padding: 16px;
    padding-top: 70px;
    padding-bottom: 120px;
  }

  .flip-card {
    height: var(--card-min-height);
    perspective: 1000px;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    background: white;
  }
  .flip-card.new-arrival {
    opacity: 0;
    transform: scale(0.95);
    animation: cardArrival 0.4s ease forwards;
  }
  @keyframes cardArrival { to { transform: scale(1); opacity: 1; } }
  .flip-card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
  .flipped .flip-card-inner { transform: rotateY(180deg); }
  .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; }
  .card-front { background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); }
  .card-back  { transform: rotateY(180deg); background: linear-gradient(135deg, #ffffff 0%, #fafbff 100%); }
  .question-div, .response-content { padding: 16px; flex-grow: 1; overflow-y: auto; font-size: 15px; line-height: 1.5; }

  .flip-card.selected { outline: 4px solid #0066ff; outline-offset: -4px; transform: scale(1.02); z-index: 20; }

  #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.8); color: white; padding: 25px 40px; border-radius: 12px; display: none; z-index: 2000; }
  #loading.show { display: block; }
  #savedNotice { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 12px 24px; border-radius: 25px; opacity: 0; transition: opacity 0.3s; }
  #savedNotice.show { opacity: 1; }

  #inputPanel { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255,255,255,0.95); border-top: 1px solid #ddd; padding: 16px; backdrop-filter: blur(20px); box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
  .input-container { display: flex; gap: 10px; align-items: center; max-width: 1200px; margin: 0 auto; }

  #moreMenuBtn { position: fixed; bottom: 120px; right: 20px; background: rgba(255,255,255,0.9); border: 1px solid #ddd; width: 56px; height: 56px; border-radius: 50%; font-size: 28px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 900; }
  #moreModal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(5px); }
  #moreModal.active { display: flex; }
  .modal-content { background: white; border-radius: 16px; padding: 30px; width: 90%; max-width: 400px; max-height: 80vh; overflow-y: auto; }
  #saveApiBtn { background: #0066ff; color: white; border: none; padding: 12px; border-radius: 8px; width: 100%; margin-top: 10px; cursor: pointer; font-size: 16px; }

  .card-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    padding: 16px;
    display: none;
    flex-direction: column;
    gap: 12px;
    z-index: 100;
  }
  .card-menu.active { display: flex; }
  .menu-btn { background: none; border: none; font-size: 24px; cursor: pointer; padding: 8px; text-align: center; border-radius: 8px; transition: background 0.2s; }
  .menu-btn:hover { background: rgba(0, 102, 255, 0.1); }

  #mergePromptModal, #continuePromptModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000;
  }
  #mergePromptModal.active, #continuePromptModal.active { display: flex; }
  .prompt-content { background: white; border-radius: 16px; padding: 24px; width: 90%; max-width: 600px; }
  #mergePromptText, #continuePromptText { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 15px; min-height: 120px; resize: vertical; }

  /* Split Modal Styles */
  #splitModal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1000; }
  #splitModal.active { display: flex; }
  #splitText { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 15px; min-height: 200px; resize: vertical; }
</style>
</head>
<body>

<div id="selectionBar">
  <button id="cancelSelect"></button>
  <span id="selectCount">1 selected</span>
  <button id="mergeSelected">Merge</button>
</div>

<div class="fullscreen-overlay" id="fullscreenOverlay">
  <div class="fullscreen-card">
    <div class="fullscreen-inner">
      <div class="fullscreen-face fullscreen-front">
        <div class="fullscreen-header">
          <span class="fullscreen-title">Question</span>
          <div>
            <button class="fullscreen-flip" title="Flip to Response"></button>
            <button class="fullscreen-split" style="display:none;" title="Split"></button>
            <button class="fullscreen-close" title="Close">×</button>
          </div>
        </div>
        <div class="fullscreen-content" id="fsQuestion" contenteditable="false"></div>
      </div>
      <div class="fullscreen-face fullscreen-back">
        <div class="fullscreen-header">
          <span class="fullscreen-title">Response</span>
          <div>
            <button class="fullscreen-flip" title="Flip to Question"></button>
            <button class="fullscreen-split" style="display:none;" title="Split"></button>
            <button class="fullscreen-close" title="Close">×</button>
          </div>
        </div>
        <div class="fullscreen-content" id="fsResponse" contenteditable="false"></div>
      </div>
    </div>
  </div>
</div>

<div id="grid"></div>

<div id="loading"> Thinking...</div>
<div id="savedNotice"> Saved!</div>

<button id="moreMenuBtn"></button>

<div id="moreModal">
  <div class="modal-content">
    <h3>Settings & Actions</h3>
    <input type="url" id="modalBaseUrl" placeholder="API Base URL" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 8px;">
    <button id="saveApiBtn"> Save API URL</button>
    
    <div style="margin-top: 24px; border-top: 1px solid #eee; padding-top: 16px;">
      <button class="modal-btn" id="modalExport" style="width: 100%; padding: 12px; margin: 6px 0; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-size: 16px;"> Export State</button>
      <button class="modal-btn" id="modalImport" style="width: 100%; padding: 12px; margin: 6px 0; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-size: 16px;"> Import State</button>
      <button class="modal-btn" id="modalSummarize" style="width: 100%; padding: 12px; margin: 6px 0; border: 1px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-size: 16px;"> Summarize Context</button>
    </div>
    
    <button class="modal-btn" id="modalClose" style="width: 100%; padding: 12px; margin: 6px 0; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px;"> Close</button>
    
    <input type="file" id="fileInput" accept=".json" style="display:none;">
  </div>
</div>

<div id="cardMenu" class="card-menu">
  <button class="menu-btn" data-action="continue"> Continue</button>
  <button class="menu-btn" data-action="copy"> Copy</button>
  <button class="menu-btn" data-action="edit"> Edit</button>
  <button class="menu-btn" data-action="split"> Split</button>
  <button class="menu-btn" data-action="fullscreen"> Fullscreen</button>
  <button class="menu-btn" data-action="delete" style="color: #d00;"> Delete</button>
</div>

<div id="mergePromptModal">
  <div class="prompt-content">
    <h3>Merge Instructions (optional)</h3>
    <p>If blank, will use questions as context</p>
    <textarea id="mergePromptText" placeholder="How should these be merged?"></textarea>
    <div style="display:flex;gap:12px;justify-content:flex-end;margin-top:16px;">
      <button id="mergePromptCancel">Cancel</button>
      <button id="mergePromptConfirm" style="background:#0066ff;color:white;padding:8px 16px;border-radius:8px;border:none;">Merge</button>
    </div>
  </div>
</div>

<div id="continuePromptModal">
  <div class="prompt-content">
    <h3>Continue Instructions (optional)</h3>
    <p>If blank, will simply continue the previous response</p>
    <textarea id="continuePromptText" placeholder="What should the continuation focus on?"></textarea>
    <div style="display:flex;gap:12px;justify-content:flex-end;margin-top:16px;">
      <button id="continuePromptCancel">Cancel</button>
      <button id="continuePromptConfirm" style="background:#0066ff;color:white;padding:8px 16px;border-radius:8px;border:none;">Continue</button>
    </div>
  </div>
</div>

<div id="splitModal">
  <div class="prompt-content">
    <h3>Split Response</h3>
    <p>Add "---" between sections to split</p>
    <textarea id="splitText" placeholder="Enter text with --- separators"></textarea>
    <div style="display:flex;gap:12px;justify-content:flex-end;margin-top:16px;">
      <button id="splitCancel">Cancel</button>
      <button id="splitConfirm" style="background:#0066ff;color:white;padding:8px 16px;border-radius:8px;border:none;">Split</button>
    </div>
  </div>
</div>

<div id="inputPanel">
  <div class="input-container">
    <select id="modeSelect" style="padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; background: white;">
      <option value="chat"> Chat</option>
      <option value="generate"> Generate</option>
      <option value="code"> Code</option>
    </select>
    <input type="text" id="userInput" placeholder="Ask anything..." style="flex: 1; padding: 12px 16px; border: 2px solid #e1e1e1; border-radius: 12px; font-size: 16px;">
    <button id="sendBtn" style="background:#0066ff;color:white;border:none;padding:12px 20px;border-radius:10px;cursor:pointer;font-weight:600;"> Send</button>
  </div>
</div>

<script>
class AICardSystem {
  constructor() {
    this.pairs = [];
    this.sessionId = "main-" + Date.now();
    this.currentStreamingId = null;
    this.selectedTiles = new Set();
    this.isSelectMode = false;
    this.fullscreenId = null;
    this.isEditMode = false;
    this.currentContinueId = null;
    this.textDecoder = new TextDecoder('utf-8');
  }

  init() {
    this.loadFromStorage();
    this.bindEvents();
  }

  bindEvents() {
    document.getElementById('sendBtn').onclick = () => this.sendMessage();
    document.getElementById('userInput').onkeydown = e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.sendMessage(); }
    };

    document.getElementById('moreMenuBtn').onclick = () => {
      document.getElementById('modalBaseUrl').value = localStorage.getItem('ai-baseurl') || '';
      document.getElementById('moreModal').classList.add('active');
    };
    document.getElementById('modalClose').onclick = () => document.getElementById('moreModal').classList.remove('active');
    document.getElementById('saveApiBtn').onclick = () => {
      const url = document.getElementById('modalBaseUrl').value.trim();
      if (!url) return alert('Enter API URL');
      localStorage.setItem('ai-baseurl', url);
      document.getElementById('moreModal').classList.remove('active');
      this.showNotice('API URL saved');
    };

    // Context summarizer button
    document.getElementById('modalSummarize').onclick = () => {
      document.getElementById('moreModal').classList.remove('active');
      this.summarizeContext();
    };

    document.getElementById('modalExport').onclick = () => this.exportState();
    document.getElementById('modalImport').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = e => this.importState(e);

    // Fullscreen events
    document.querySelectorAll('.fullscreen-close').forEach(b => b.onclick = () => this.closeFullscreen());
    document.querySelectorAll('.fullscreen-flip').forEach(b => b.onclick = () => document.getElementById('fullscreenOverlay').classList.toggle('flipped'));
    document.querySelectorAll('.fullscreen-split').forEach(b => b.onclick = () => this.openSplitFromFullscreen());

    // Selection and merge
    document.getElementById('cancelSelect').onclick = () => this.exitSelectMode();
    document.getElementById('mergeSelected').onclick = () => this.promptMerge();

    // Prompt modals
    document.getElementById('mergePromptCancel').onclick = () => document.getElementById('mergePromptModal').classList.remove('active');
    document.getElementById('mergePromptConfirm').onclick = () => this.mergeSelectedTiles();

    document.getElementById('continuePromptCancel').onclick = () => document.getElementById('continuePromptModal').classList.remove('active');
    document.getElementById('continuePromptConfirm').onclick = () => this.performContinue();

    // Split modal
    document.getElementById('splitCancel').onclick = () => document.getElementById('splitModal').classList.remove('active');
    document.getElementById('splitConfirm').onclick = () => this.performSplit();

    // Card menu
    document.getElementById('cardMenu').addEventListener('click', e => {
      const btn = e.target.closest('.menu-btn');
      if (btn) {
        const action = btn.dataset.action;
        this.handleMenuAction(action, this.currentCardMenuId);
        document.getElementById('cardMenu').classList.remove('active');
      }
    });

    document.addEventListener('click', e => {
      if (!e.target.closest('#cardMenu')) document.getElementById('cardMenu').classList.remove('active');
    });
  }

  handleMenuAction(action, id) {
    if (action === 'continue') this.promptContinue(id);
    if (action === 'copy') this.copyResponse(id);
    if (action === 'edit') this.startFullscreenEdit(id);
    if (action === 'split') this.openSplit(id);
    if (action === 'fullscreen') this.openFullscreen(id);
    if (action === 'delete') if (confirm('Delete this card?')) this.deletePair(id);
  }

  // FIXED: Fullscreen now properly shows both question and response
  openFullscreen(id, startOnResponse = false) {
    const p = this.pairs.find(x => x.id === id);
    if (!p) return;
    
    // Clear any previous edit state
    this.isEditMode = false;
    document.getElementById('fsQuestion').contentEditable = false;
    document.getElementById('fsResponse').contentEditable = false;
    document.querySelectorAll('.fullscreen-split').forEach(b => b.style.display = 'none');

    // Populate both sides
    document.getElementById('fsQuestion').innerHTML = this.safeRenderMarkdown(p.question);
    document.getElementById('fsResponse').innerHTML = p.response && p.response !== '...' 
      ? this.safeRenderMarkdown(p.response) 
      : '<div class="streaming-indicator"><span class="streaming-cursor"></span> Generating...</div>';

    const overlay = document.getElementById('fullscreenOverlay');
    overlay.classList.add('active');
    if (startOnResponse) overlay.classList.add('flipped');
    else overlay.classList.remove('flipped');
    this.fullscreenId = id;
    document.body.style.overflow = 'hidden';
  }

  copyResponse(id) {
    const tile = this.pairs.find(p => p.id === id);
    if (tile && tile.response) {
      navigator.clipboard.writeText(tile.response);
      this.showNotice('Copied to clipboard');
    }
  }

  promptContinue(id) {
    this.currentContinueId = id;
    document.getElementById('continuePromptText').value = '';
    document.getElementById('continuePromptModal').classList.add('active');
  }

  performContinue() {
    const tile = this.pairs.find(p => p.id === this.currentContinueId);
    if (!tile) return;

    const custom = document.getElementById('continuePromptText').value.trim();
    const prompt = custom 
      ? `Previous response:\n\n${tile.response || ''}\n\nUser instruction for continuation:\n${custom}`
      : `Continue the previous response thoughtfully:\n\n${tile.response || ''}\n\nContinuing:`;

    const newId = this.addPair({ question: `Continue: ${tile.question.slice(0,40)}...`, response: '...' }, true);
    this.currentStreamingId = newId;
    this.sendWithPrompt(prompt);
    document.getElementById('continuePromptModal').classList.remove('active');
  }

  startFullscreenEdit(id) {
    this.openFullscreen(id);
    this.isEditMode = true;
    document.getElementById('fsQuestion').contentEditable = true;
    document.getElementById('fsResponse').contentEditable = true;
    document.querySelectorAll('.fullscreen-split').forEach(b => b.style.display = 'block');
    this.showNotice('Editing — flip to switch sides, close to save');
  }

  openSplitFromFullscreen() {
    const response = document.getElementById('fsResponse').innerText;
    document.getElementById('splitText').value = response;
    document.getElementById('splitModal').classList.add('active');
  }

  closeFullscreen() {
    if (this.isEditMode && this.fullscreenId) {
      const pair = this.pairs.find(p => p.id === this.fullscreenId);
      if (pair) {
        pair.question = document.getElementById('fsQuestion').innerText.trim();
        pair.response = document.getElementById('fsResponse').innerHTML;
        this.saveToStorage();
        this.showNotice('Changes saved');
      }
      this.isEditMode = false;
      document.querySelectorAll('.fullscreen-split').forEach(b => b.style.display = 'none');
    }
    document.getElementById('fullscreenOverlay').classList.remove('active', 'flipped');
    this.fullscreenId = null;
    document.body.style.overflow = 'auto';
  }

  getBaseUrl() {
    const url = localStorage.getItem('ai-baseurl');
    if (!url) throw new Error('Set and save API URL in  menu');
    return url.replace(/\/+$/, '');
  }

  async sendMessage() {
    const input = document.getElementById('userInput').value.trim();
    if (!input) return;
    document.getElementById('userInput').value = '';

    const id = this.addPair({ question: input, response: '...' }, true);
    this.currentStreamingId = id;

    try {
      document.getElementById('loading').classList.add('show');
      const mode = document.getElementById('modeSelect').value;
      const payload = { sessionId: this.sessionId };
      payload[mode === 'chat' ? 'message' : 'prompt'] = input;

      const path = mode === 'code' ? '/api/code' : mode === 'generate' ? '/api/generate' : '/api/chat';
      const reader = await this.apiFetch(path, payload);
      await this.processSSEStream(reader, id);
    } catch (err) {
      this.updateResponse(id, `<p style="color:red">Error: ${this.escapeHTML(err.message)}</p>`);
    } finally {
      document.getElementById('loading').classList.remove('show');
      this.currentStreamingId = null;
    }
  }

  async apiFetch(path, payload) {
    const base = this.getBaseUrl();
    const res = await fetch(base + path, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      let msg = `HTTP ${res.status}`;
      try { const j = await res.json(); msg = j.error || j.message || msg; } catch {}
      throw new Error(msg);
    }
    return res.body.getReader();
  }

  async processSSEStream(reader, tileId) {
    let buffer = '';
    let accumulated = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += this.textDecoder.decode(value, { stream: true });
        const parts = buffer.split(/\r?\n\r?\n/);
        buffer = parts.pop() || '';

        for (const part of parts) {
          if (!part.trim()) continue;
          const lines = part.split(/\r?\n/);
          let jsonData = null;

          for (const line of lines) {
            if (line.startsWith('data:')) {
              const data = line.substring(5).trim();
              if (data === '[DONE]') {
                let clean = accumulated.trim();
                clean = clean.replace(/\n{3,}/g, '\n\n').trim();
                const html = clean ? this.safeRenderMarkdown(clean) : '<em>No content</em>';
                this.updateResponse(tileId, html);
                const tile = this.pairs.find(t => t.id === tileId);
                if (tile) tile.response = clean;
                this.saveToStorage();
                return;
              }
              try { jsonData = JSON.parse(data); } catch {}
            }
          }

          if (jsonData?.choices?.[0]?.delta?.content) {
            const content = jsonData.choices[0].delta.content;
            accumulated += content;
            this.updateResponse(tileId, this.safeRenderMarkdown(accumulated), true);
          }
        }
      }
    } catch (err) {
      this.updateResponse(tileId, `<p style="color:red">Error: ${this.escapeHTML(err.message)}</p>`);
    }
  }

  updateResponse(tileId, html, isStreaming = false) {
    const card = document.querySelector(`[data-id="${tileId}"]`);
    if (card) {
      const resp = card.querySelector('.response-content');
      if (resp) {
        resp.innerHTML = html;
        resp.scrollTop = resp.scrollHeight;
      }
    }
    if (this.fullscreenId === tileId) {
      const fs = document.getElementById('fsResponse');
      if (fs) {
        fs.innerHTML = html;
        fs.scrollTop = fs.scrollHeight;
      }
    }
  }

  addPair(pairData, fullscreen = false) {
    const id = crypto.randomUUID?.() || Date.now().toString();
    const pair = { id, question: pairData.question, response: pairData.response || '' };
    this.pairs.push(pair);

    this.renderPair(pair, true);

    if (fullscreen) this.openFullscreen(id, true);

    this.saveToStorage();
    return id;
  }

  renderPair(p, isNew = false) {
    const responseHTML = p.response && p.response !== '...'
      ? this.safeRenderMarkdown(p.response)
      : '<div class="streaming-indicator"><span class="streaming-cursor"></span> Generating...</div>';

    const card = document.createElement('div');
    card.className = `flip-card ${isNew ? 'new-arrival' : ''}`;
    card.dataset.id = p.id;

    card.innerHTML = `
      <div class="flip-card-inner">
        <div class="card-face card-front">
          <div class="question-div">${this.safeRenderMarkdown(p.question)}</div>
        </div>
        <div class="card-face card-back">
          <div class="response-content">${responseHTML}</div>
        </div>
      </div>
    `;

    let longPressTimer;
    card.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        longPressTimer = setTimeout(() => this.enterSelectMode(p.id, card), 600);
      }
    }, { passive: true });
    card.addEventListener('touchend', () => clearTimeout(longPressTimer));
    card.addEventListener('touchmove', () => clearTimeout(longPressTimer));

    card.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        this.currentCardMenuId = p.id;
        document.getElementById('cardMenu').classList.add('active');
      }
    });

    card.addEventListener('click', e => {
      if (this.isSelectMode) {
        e.preventDefault();
        this.toggleCardSelection(p.id, card);
        return;
      }
      card.classList.toggle('flipped');
    });

    card.ondblclick = e => { e.preventDefault(); this.openFullscreen(p.id); };

    document.getElementById('grid').appendChild(card);
    if (p.response && p.response !== '...') setTimeout(() => card.classList.add('flipped'), 100);
  }

  async summarizeContext() {
    if (this.pairs.length < 3) {
      this.showNotice('Need at least 3 cards to summarize');
      return;
    }

    try {
      document.getElementById('loading').textContent = ' Summarizing context...';
      document.getElementById('loading').classList.add('show');

      const recentCards = this.pairs.slice(-10); // Last 10 cards for summary
      const contextText = recentCards.map((card, i) => 
        `Card ${i + 1}: ${card.question}\n${card.response || 'No response yet'}\n`
      ).join('\n---\n\n');

      const summaryPrompt = `You are an expert knowledge manager. Please create a concise, thematic summary that captures the key insights, patterns, and main ideas from these recent thoughts and responses. Focus on connections and overarching themes:

${contextText}

Provide a summary that:
1. Identifies the main themes
2. Notes key insights or patterns
3. Suggests potential next directions
4. Is concise but comprehensive

Summary:`;

      const reader = await this.apiFetch('/api/chat', {
        sessionId: this.sessionId,
        message: summaryPrompt
      });

      let summaryContent = '';
      const finalSummary = await this.processSummaryStream(reader, (content) => {
        summaryContent += content;
      });

      // Create summary card
      this.addPair({
        question: ` Summary of ${recentCards.length} recent cards`,
        response: finalSummary || summaryContent
      });

      this.showNotice(`Context summarized! Created summary card`);
      
    } catch (err) {
      this.showNotice(`Summarization failed: ${err.message}`, 'error');
    } finally {
      document.getElementById('loading').classList.remove('show');
    }
  }

  async processSummaryStream(reader, onContent) {
    let buffer = '';
    let summary = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += this.textDecoder.decode(value, { stream: true });
        const parts = buffer.split(/\r?\n\r?\n/);
        buffer = parts.pop() || '';

        for (const part of parts) {
          if (!part.trim()) continue;
          
          const lines = part.split(/\r?\n/);
          for (const line of lines) {
            if (line.startsWith('data:')) {
              const data = line.substring(5).trim();
              if (data === '[DONE]') {
                return summary.trim();
              }
              
              try {
                const jsonData = JSON.parse(data);
                if (jsonData?.choices?.[0]?.delta?.content) {
                  const content = jsonData.choices[0].delta.content;
                  summary += content;
                  onContent(content);
                }
              } catch {}
            }
          }
        }
      }
    } catch (err) {
      throw new Error(`Summary stream error: ${err.message}`);
    }

    return summary.trim();
  }

  promptMerge() {
    if (this.selectedTiles.size < 2) return;
    document.getElementById('mergePromptText').value = '';
    document.getElementById('mergePromptModal').classList.add('active');
  }

  mergeSelectedTiles() {
    const selected = this.pairs.filter(p => this.selectedTiles.has(p.id));
    let context = selected.map(t => t.question).join('\n\n');
    const customPrompt = document.getElementById('mergePromptText').value.trim();
    const prompt = customPrompt || `Combine these ideas intelligently:\n\n${context}\n\nCreate a synthesized response that integrates all perspectives:`;
    const newId = this.addPair({ question: `Merged ${selected.length} cards`, response: '...' }, true);
    this.currentStreamingId = newId;
    this.sendWithPrompt(prompt);
    document.getElementById('mergePromptModal').classList.remove('active');
    this.exitSelectMode();
  }

  async sendWithPrompt(prompt) {
    try {
      document.getElementById('loading').classList.add('show');
      const mode = document.getElementById('modeSelect').value;
      const payload = { sessionId: this.sessionId };
      payload[mode === 'chat' ? 'message' : 'prompt'] = prompt;
      const path = mode === 'code' ? '/api/code' : mode === 'generate' ? '/api/generate' : '/api/chat';
      const reader = await this.apiFetch(path, payload);
      await this.processSSEStream(reader, this.currentStreamingId);
    } catch (err) {
      this.updateResponse(this.currentStreamingId, `<p style="color:red">Error: ${this.escapeHTML(err.message)}</p>`);
    } finally {
      document.getElementById('loading').classList.remove('show');
    }
  }

  openSplit(id) {
    const p = this.pairs.find(x => x.id === id);
    if (p) {
      document.getElementById('splitText').value = p.response || '';
      document.getElementById('splitModal').classList.add('active');
      this.currentSplitId = id;
    }
  }

  performSplit() {
    const text = document.getElementById('splitText').value;
    const parts = text.split(/\n?---+\n?/).map(t => t.trim()).filter(t => t);
    
    if (parts.length < 2) {
      alert('Use --- to separate sections (need at least 2 parts)');
      return;
    }

    // If splitting from existing card, get the original question
    const orig = this.currentSplitId ? this.pairs.find(x => x.id === this.currentSplitId) : null;
    const baseQuestion = orig ? orig.question : 'Split card';

    parts.forEach((part, i) => {
      this.addPair({ 
        question: `${baseQuestion} - Part ${i + 1}`, 
        response: part 
      });
    });

    document.getElementById('splitModal').classList.remove('active');
    this.currentSplitId = null;
  }

  deletePair(id) {
    this.pairs = this.pairs.filter(p => p.id !== id);
    document.querySelector(`[data-id="${id}"]`)?.remove();
    if (this.fullscreenId === id) this.closeFullscreen();
    this.saveToStorage();
  }

  enterSelectMode(id, card) {
    this.isSelectMode = true;
    this.selectedTiles.clear();
    this.toggleCardSelection(id, card);
  }

  toggleCardSelection(id, card) {
    card.classList.toggle('selected');
    if (this.selectedTiles.has(id)) this.selectedTiles.delete(id);
    else this.selectedTiles.add(id);
    this.updateSelectionBar();
  }

  updateSelectionBar() {
    const count = this.selectedTiles.size;
    document.getElementById('selectCount').textContent = `${count} selected`;
    document.getElementById('mergeSelected').style.display = count >= 2 ? 'block' : 'none';
    document.getElementById('selectionBar').classList.toggle('active', count > 0);
  }

  exitSelectMode() {
    this.isSelectMode = false;
    this.selectedTiles.clear();
    document.querySelectorAll('.flip-card.selected').forEach(c => c.classList.remove('selected'));
    document.getElementById('selectionBar').classList.remove('active');
  }

  exportState() {
    const state = { 
      pairs: this.pairs, 
      sessionId: this.sessionId,
      exportDate: new Date().toISOString(),
      version: 2
    };
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ai-cards-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    this.showNotice('Exported successfully!');
  }

  importState(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const state = JSON.parse(ev.target.result);
        if (!state.pairs || !Array.isArray(state.pairs)) {
          throw new Error('Invalid file format');
        }
        
        this.pairs = state.pairs || [];
        this.sessionId = state.sessionId || this.sessionId;
        document.getElementById('grid').innerHTML = '';
        this.pairs.forEach(p => this.renderPair(p));
        this.saveToStorage();
        this.showNotice('Imported successfully!');
      } catch (err) {
        alert(`Import failed: ${err.message}`);
      }
    };
    reader.readAsText(file);
    e.target.value = '';
  }

  saveToStorage() {
    localStorage.setItem('ai-data', JSON.stringify({ 
      pairs: this.pairs, 
      sessionId: this.sessionId 
    }));
  }

  loadFromStorage() {
    const raw = localStorage.getItem('ai-data');
    if (raw) {
      try {
        const data = JSON.parse(raw);
        this.pairs = data.pairs || [];
        this.sessionId = data.sessionId || this.sessionId;
        this.pairs.forEach(p => this.renderPair(p));
      } catch (err) {
        console.error('Failed to load data:', err);
        this.pairs = [];
      }
    }
  }

  escapeHTML(str = '') {
    return str.replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#039;');
  }

  safeRenderMarkdown(md) {
    try {
      const html = marked.parse(md || '');
      return DOMPurify.sanitize(html);
    } catch (e) {
      return this.escapeHTML(md || '');
    }
  }

  showNotice(msg, type = 'success') {
    const n = document.getElementById('savedNotice');
    n.textContent = msg;
    n.style.background = type === 'error' ? '#d00' : '#333';
    n.classList.add('show');
    setTimeout(() => n.classList.remove('show'), 2000);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  window.aiCardSystem = new AICardSystem();
  aiCardSystem.init();
});
</script>
</body>
</html>