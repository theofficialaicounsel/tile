<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5.0,user-scalable=yes" />
  <title>AI Mind Map — Streaming Fullscreen Auto-Scroll</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <style>
   /* Theme & layout */
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0a0a0a; --glass:rgba(26,26,26,0.86);
  --yellow:#ffd700; --text:#fff; --border:rgba(255,215,0,0.28);
  --blue:#6496ff;
  --card-min-height:200px; /* Slightly taller base height to give text room */
}
html,body{height:100%}
body{font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);display:flex;flex-direction:column;height:100vh;overflow:hidden}

.header{height:50px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;background:rgba(10,10,10,0.95);border-bottom:2px solid var(--yellow);z-index:1000}
.logo{color:var(--yellow);font-weight:700;cursor:pointer}

.main-container{flex:1;display:flex;flex-direction:column;overflow:hidden}

.input-panel{background:rgba(10,10,10,0.95);padding:12px;overflow:auto;transition:height .12s,opacity .12s;min-height:0}
.section{margin-bottom:12px}
.section-title{font-size:.75rem;color:var(--yellow);margin-bottom:8px;text-transform:uppercase}
select,textarea,input{width:100%;background:var(--glass);color:var(--text);border:1px solid var(--border);padding:8px;border-radius:6px;font-family:inherit;margin-bottom:8px}
textarea{min-height:80px;resize:vertical}
.send-btn{background:var(--yellow);color:var(--bg);border:none;padding:10px 14px;border-radius:6px;font-weight:700}

.resize-divider{height:8px;background:var(--yellow);cursor:ns-resize;border-top:1px solid var(--border);border-bottom:1px solid var(--border);flex-shrink:0}

.canvas{flex:1;overflow:auto;padding:8px;background:var(--bg)}

/* Grid: 2 columns on mobile, responsive elsewhere */
.grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(280px,1fr));
  gap:12px;
  align-items:start;
}
@media (max-width:768px){
  .grid{
    grid-template-columns:repeat(2,1fr);
    gap:10px;
  }
}

/* Flip cards - restored original look */
.flip-card{
  position:relative;
  border-radius:8px;
  border:2px solid var(--border);
  overflow:hidden;
  background:var(--bg);
  min-height:var(--card-min-height);
}
.flip-card-inner{
  width:100%;
  height:100%;
  transition:transform .6s;
  transform-style:preserve-3d;
  border-radius:8px;
}
.flip-card.flipped .flip-card-inner{
  transform:rotateY(180deg);
}

.card-face{
  position:absolute;
  width:100%;
  height:100%;
  backface-visibility:hidden;
  display:flex;
  flex-direction:column;
  padding:12px;
  border-radius:8px;
  background:var(--glass);
}

/* Front face - yellow indicator stays, but text gets space */
.card-front{
  border-left:4px solid var(--yellow);
  background:linear-gradient(135deg, rgba(255,215,0,0.06), rgba(255,215,0,0.02));
  padding-left:16px; /* Push content away from the thick yellow bar */
}

/* Back face */
.card-back{
  transform:rotateY(180deg);
  border-left:4px solid var(--blue);
  background:linear-gradient(135deg, rgba(100,150,255,0.06), rgba(100,150,255,0.02));
}

/* KEY FIX: Question text now guaranteed to show */
.question-div{
  flex:1 1 auto;
  min-height:0; /* Allows flex shrink properly */
  overflow:hidden;
  white-space:pre-wrap;
  word-break:break-word;
  padding-right:4px;
  cursor:default;
  color:var(--text);
  font-size:1rem;
  line-height:1.5;
  margin-top:4px;
  display:-webkit-box;
  -webkit-line-clamp:10;
  -webkit-box-orient:vertical;
  text-overflow:ellipsis;
}

.response-content{
  flex:1;
  overflow:auto;
  white-space:pre-wrap;
  word-break:break-word;
  font-family:monospace;
  padding-right:4px;
}

.card-actions{
  display:flex;
  gap:8px;
  margin-top:8px;
  border-top:1px solid var(--border);
  padding-top:6px;
  justify-content:flex-end;
  flex-wrap:wrap;
}

.card-btn{
  background:rgba(0,0,0,0.5);
  border:none;
  color:var(--text);
  width:36px;
  height:36px;
  border-radius:50%;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  padding:6px;
}

/* Icons */
.icon {width:18px;height:18px;display:block}
.card-btn svg, .fullscreen-card-btn svg {width:18px;height:18px;filter:drop-shadow(0 2px 3px rgba(0,0,0,0.6));}
.fullscreen-card-btn{
  background:rgba(0,0,0,0.45);
  border:none;
  color:var(--text);
  width:40px;
  height:40px;
  border-radius:8px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
}

/* Modals, fullscreen, loading, etc. (unchanged) */
.modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:2000;align-items:center;justify-content:center;padding:20px;overflow:auto}
.modal.show{display:flex}
.modal-content{background:var(--glass);border:2px solid var(--yellow);border-radius:12px;padding:18px;width:100%;max-width:960px;max-height:90vh;overflow:auto}

.fullscreen-overlay{display:none;position:fixed;inset:0;background:var(--bg);z-index:3000;align-items:center;justify-content:center;padding:20px;overflow:hidden;border:4px solid var(--yellow);border-radius:12px;box-shadow:0 0 50px rgba(255,215,0,0.2)}
.fullscreen-overlay.show{display:flex}
.fullscreen-overlay.streaming::before{content:'Streaming...';position:absolute;top:10px;right:10px;background:var(--yellow);color:var(--bg);padding:4px 8px;border-radius:4px;font-size:0.8rem;font-weight:bold;z-index:3001}
.fullscreen-main-content{width:96%;height:94%;max-width:1200px;max-height:86vh;display:flex;flex-direction:column;background:transparent}
.fullscreen-card-inner{width:100%;height:100%;transition:transform .6s;transform-style:preserve-3d;border-radius:8px;position:relative}
.fullscreen-card-inner.flipped{transform:rotateY(180deg)}
.fullscreen-card-face{position:absolute;width:100%;height:100%;backface-visibility:hidden;display:flex;flex-direction:column;padding:20px;border-radius:8px;background:var(--glass);box-shadow:inset 0 0 20px rgba(0,0,0,0.6)}
.fullscreen-card-face.card-front{border-left:4px solid var(--yellow)}
.fullscreen-card-face.card-back{transform:rotateY(180deg);border-left:4px solid var(--blue)}

.fullscreen-question-text{font-weight:700;color:var(--yellow);margin-bottom:12px}
.fullscreen-response-content{flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;padding-right:8px;font-family:'Consolas','Monaco','Courier New',monospace;line-height:1.5;font-size:16px}

.loading{position:fixed;bottom:18px;right:18px;background:var(--glass);padding:12px 16px;border-radius:8px;border:1px solid var(--yellow);display:none;z-index:999}
.loading.show{display:block}
.saved-notice{position:fixed;bottom:18px;left:50%;transform:translateX(-50%);background:rgba(0,255,0,0.08);color:#0f0;border:1px solid #0f0;padding:10px 14px;border-radius:8px;z-index:999;opacity:0;transition:opacity .18s}
.saved-notice.show{opacity:1}

/* Streaming animations */
.streaming-cursor{display:inline-block;width:8px;height:1em;background-color:var(--yellow);margin-left:2px;animation:blink 1s infinite;vertical-align:middle}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0}}
.streaming-indicator{position:absolute;top:10px;right:10px;color:var(--yellow);font-size:0.8rem;animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}

/* Compose modal */
.compose-text{min-height:300px;max-height:70vh;resize:vertical;width:100%;padding:12px;border-radius:8px;background:var(--bg);border:1px solid var(--border);color:var(--text)}
 </style>
</head>
<body>
  <div class="header">
    <div class="logo" id="logoBtn">ai-nspired.com</div>
    <div style="display:flex;gap:10px;align-items:center">
      <button id="settingsOpenBtn">Settings</button>
      <button id="runTestsBtn" class="send-btn">Run tests</button>
    </div>
  </div>

  <div class="main-container">
    <div class="input-panel" id="inputPanel">
      <div class="section">
        <div class="section-title">Mode</div>
        <select id="modeSelect">
          <option value="chat">Chat</option>
          <option value="code">Code</option>
          <option value="generate">Generate</option>
        </select>
      </div>

      <div class="section">
        <div class="section-title">Message / Prompt</div>
        <textarea id="userInput" placeholder="you can ask whatever you like..."></textarea>
        <div style="display:flex;gap:10px">
          <button id="sendBtn" class="send-btn">send</button>
          <button id="composeOpenBtn" class="send-btn" title="Open larger compose box">Compose</button>
        </div>
      </div>
    </div>

    <div class="resize-divider" id="resizeDivider" title="Drag to resize • Double-click to toggle collapse"></div>

    <div class="canvas" id="canvas">
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <div class="saved-notice" id="savedNotice">Saved!</div>
  <div class="loading" id="loading">Processing...</div>

  <!-- Settings -->
  <div class="modal" id="settingsModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.2rem;color:var(--yellow);margin-bottom:12px;text-align:center">Settings</div>
      <div class="section"><div class="section-title">API Base URL</div><input id="baseUrl" placeholder="https://your-worker.workers.dev"/></div>
      <div class="section"><div class="section-title">Session ID</div><input id="sessionIdInput" readonly/></div>
      <div style="display:flex;gap:10px;margin-top:12px">
        <button id="exportBtn">Export</button>
        <label for="importFile" class="send-btn" style="cursor:pointer">Import</label>
        <input id="importFile" type="file" accept=".json" style="display:none"/>
      </div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="settingsCancelBtn">Cancel</button>
        <button id="settingsSaveBtn" class="send-btn">Save</button>
      </div>
    </div>
  </div>

  <!-- Edit -->
  <div class="modal" id="editModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.1rem;color:var(--yellow);margin-bottom:12px">Edit Tile <span id="editTileIdDisplay"></span></div>
      <div class="section"><div class="section-title">Question / Intro</div><textarea id="editQuestion"></textarea></div>
      <div class="section">
        <div class="section-title">Response Markdown <button id="editTogglePreview" type="button">Preview</button></div>
        <textarea id="editResponse"></textarea>
        <div class="markdown-preview" id="editPreview" style="display:none"></div>
      </div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="editCancelBtn">Cancel</button>
        <button id="editSaveBtn" class="send-btn">Save</button>
      </div>
    </div>
  </div>

  <!-- Compose (full text) -->
  <div class="modal" id="composeModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.1rem;color:var(--yellow);margin-bottom:12px">Compose — larger editor</div>
      <textarea id="composeInput" class="compose-text" placeholder="Write long content here..."></textarea>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="composeCancelBtn">Cancel</button>
        <button id="composeSendBtn" class="send-btn">Send</button>
      </div>
    </div>
  </div>

  <!-- Fullscreen -->
  <div class="fullscreen-overlay" id="fullscreenOverlay" aria-hidden="true">
    <div class="fullscreen-main-content">
      <div class="fullscreen-card-inner" id="fullscreenInner">
        <div class="fullscreen-card-face card-front">
          <div class="fullscreen-question-text" style="flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;padding-right:8px;line-height:1.5;font-size:16px;"></div>
          <div style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end">
            <button class="fullscreen-card-btn" data-action="flip" title="Flip">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12v6a2 2 0 0 1-2 2H7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12V6a2 2 0 0 1 2-2h12"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9l-4 4 4 4"/></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="edit" title="Edit">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="followup" title="Follow up">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="delete" title="Delete">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 11v6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 11v6"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="close" title="Close">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
          </div>
        </div>

        <div class="fullscreen-card-face card-back">
          <div class="fullscreen-response-content" style="flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;padding-right:8px;font-family:'Consolas','Monaco','Courier New',monospace;line-height:1.5;font-size:16px;"></div>
          <div style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end">
            <button class="fullscreen-card-btn" data-action="flip" title="Flip">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12v6a2 2 0 0 1-2 2H7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12V6a2 2 0 0 1 2-2h12"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9l-4 4 4 4"/></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="edit" title="Edit">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="followup" title="Follow up">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="delete" title="Delete">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 11v6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 11v6"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="close" title="Close">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Core variables
let pairs = [];
let history = [];
let sessionId = "main-" + Date.now();
let accumulatedAIResponse = "";
let currentTileIdForStreaming = null;
let editingTileId = null;
let currentFullscreenTileId = null;
const textDecoder = (typeof TextDecoder !== 'undefined') ? new TextDecoder('utf-8') : null;

// DOM Elements
const gridElement = document.getElementById('grid');
const userInputElement = document.getElementById('userInput');
const modeSelectElement = document.getElementById('modeSelect');
const baseUrlInput = document.getElementById('baseUrl');
const sessionIdInput = document.getElementById('sessionIdInput');
const settingsModal = document.getElementById('settingsModal');
const editModal = document.getElementById('editModal');
const editQuestionTextarea = document.getElementById('editQuestion');
const editResponseTextarea = document.getElementById('editResponse');
const editPreviewDiv = document.getElementById('editPreview');
const editTogglePreviewBtn = document.getElementById('editTogglePreview');
const editTileIdDisplaySpan = document.getElementById('editTileIdDisplay');
const loadingIndicator = document.getElementById('loading');
const savedNotice = document.getElementById('savedNotice');

const resizeDivider = document.getElementById('resizeDivider');
const inputPanelElement = document.getElementById('inputPanel');

const fullscreenOverlay = document.getElementById('fullscreenOverlay');
const fullscreenCardInner = document.getElementById('fullscreenInner');
const fullscreenQuestionTexts = fullscreenOverlay.querySelectorAll('.fullscreen-question-text');
const fullscreenResponseContents = fullscreenOverlay.querySelectorAll('.fullscreen-response-content');

const composeModal = document.getElementById('composeModal');
const composeInput = document.getElementById('composeInput');

// Storage keys
const STORAGE_DATA_KEY = 'mindmap-data';
const STORAGE_BASEURL_KEY = 'mindmap-baseUrl';
const STORAGE_DIVIDER_HEIGHT_KEY = 'mindmap-divider-height';

// Utility functions
function escapeHTML(str = '') {
  const d = document.createElement('div');
  d.appendChild(document.createTextNode(String(str)));
  return d.innerHTML;
}

function safeRenderMarkdown(md) {
  const html = marked.parse(md || '');
  return DOMPurify.sanitize(html);
}

function getBaseUrl() {
  return (baseUrlInput.value || '').trim().replace(/\/+$/, '');
}

// Update card min-height based on available space
function updateCardMinHeight() {
  const canvas = document.getElementById('canvas');
  if (!canvas) return;

  const inputHeight = inputPanelElement.getBoundingClientRect().height || 0;
  const availableHeight = window.innerHeight - inputHeight - 100;
  const targetHeight = Math.max(150, Math.min(availableHeight * 0.4, 400));

  document.documentElement.style.setProperty('--card-min-height', targetHeight + 'px');
}

// Add new tile pair — with auto-scroll to new card
function addPair(p) {
  const id = (window.crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : `id-\( {Date.now()}- \){Math.floor(Math.random() * 100000)}`;
  pairs.push({
    id,
    question: p.question,
    response: p.response || '',
    sessionId: p.sessionId || sessionId
  });
  renderPair(pairs[pairs.length - 1]);
  save();
  updateCardMinHeight();

  // Auto-scroll to the new card
  const newCard = gridElement.querySelector(`[data-id="${id}"]`);
  if (newCard) {
    newCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  return id;
}

// Render tile to grid
function renderPair(p) {
  let responseHTML = 'Waiting for AI...';
  if (p.response && p.response !== '...' && !p.response.startsWith('Error:')) {
    responseHTML = safeRenderMarkdown(p.response);
  } else if (p.response === '...') {
    responseHTML = '<div class="streaming-indicator"><span class="streaming-cursor"></span> Streaming...</div>';
  } else if (p.response && p.response.startsWith('Error:')) {
    responseHTML = `<p style="color:red">${escapeHTML(p.response)}</p>`;
  }

  const card = document.createElement('div');
  card.className = 'flip-card';
  card.dataset.id = p.id;

  card.innerHTML = `
    <div class="flip-card-inner">
      <div class="card-face card-front">
        <div class="question-div">${escapeHTML(p.question)}</div>
        <div class="card-actions">
          <button class="card-btn" data-action="show-fullscreen" data-id="${p.id}" title="Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7V4h3M20 7V4h-3M4 17v3h3M20 17v3h-3"/></svg>
          </button>
          <button class="card-btn" data-action="edit" data-id="${p.id}" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"/></svg>
          </button>
          <button class="card-btn delete" data-action="delete" data-id="${p.id}" title="Delete">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"/></svg>
          </button>
          <button class="card-btn" data-action="copy" data-id="${p.id}" title="Copy">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><rect x="9" y="9" width="13" height="13" rx="2"/><rect x="2" y="2" width="13" height="13" rx="2"/></svg>
          </button>
          <button class="card-btn" data-action="followup" data-id="${p.id}" title="Follow Up">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"/></svg>
          </button>
        </div>
      </div>

      <div class="card-face card-back">
        <div class="response-content">${responseHTML}</div>
        <div class="card-actions">
          <button class="card-btn" data-action="show-fullscreen" data-id="${p.id}" title="Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7V4h3M20 7V4h-3M4 17v3h3M20 17v3h-3"/></svg>
          </button>
          <button class="card-btn" data-action="edit" data-id="${p.id}" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"/></svg>
          </button>
          <button class="card-btn" data-action="copy" data-id="${p.id}" title="Copy">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><rect x="9" y="9" width="13" height="13" rx="2"/><rect x="2" y="2" width="13" height="13" rx="2"/></svg>
          </button>
        </div>
      </div>
    </div>
  `;

  card.addEventListener('click', e => {
    if (e.target.closest('.card-btn') || e.target.closest('.card-actions')) return;
    card.classList.toggle('flipped');
  });

  gridElement.appendChild(card);
}

// Update tile response with streaming support
function updateTileResponseContent(tileId, content, isStreaming = false) {
  const card = gridElement.querySelector(`[data-id="${tileId}"]`);
  if (card) {
    const responseElement = card.querySelector('.card-back .response-content');
    if (responseElement) {
      if (isStreaming) {
        responseElement.textContent = (responseElement.textContent || '') + content;
        responseElement.scrollTop = responseElement.scrollHeight;
      } else {
        responseElement.innerHTML = content;
      }
    }
  }

  if (currentFullscreenTileId === tileId) {
    fullscreenResponseContents.forEach(el => {
      if (isStreaming) {
        el.textContent = (el.textContent || '') + content;
      } else {
        el.innerHTML = content;
      }
      el.scrollTop = el.scrollHeight;
    });
  }
}

// Process streaming response
async function processSSEStream(reader, tileId) {
  showFullscreen(tileId);
  fullscreenOverlay.classList.add('streaming');

  let buffer = '';
  accumulatedAIResponse = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunkText = textDecoder ? textDecoder.decode(value, { stream: true }) : new TextDecoder('utf-8').decode(value);
      buffer += chunkText;

      // Split on SSE event boundaries (\n\n or \r\n\r\n etc.)
      const parts = buffer.split(/\r?\n\r?\n/);
      buffer = parts.pop() || '';

      for (const part of parts) {
        if (!part.trim()) continue;

        const lines = part.split(/\r?\n/);

        let isComment = false;
        let jsonData = null;

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed) continue;

          // Skip SSE comments (lines starting with ':')
          if (line[0] === ':') {
            isComment = true;
            continue;
          }

          if (trimmed.startsWith('data:')) {
            const dataStr = trimmed.substring(5).trim();
            if (dataStr === '[DONE]') {
              // Final processing (your existing cleanup code)
              let cleanResponse = accumulatedAIResponse.trim();
              // ... (keep your existing cleanup regexes here)
              cleanResponse = cleanResponse
                .replace(/\{[\s\S]*?"type"\s*:\s*"tool_use"[\s\S]*?\}/g, '')
                .replace(/\{[\s\S]*?"function"[\s\S]*?\}/g, '')
                .replace(/```json\s*\{[\s\S]*?\}\s*```/g, '')
                .replace(/\{[\s\S]*?"choices"\s*:\s*\[\s*\][\s\S]*?\}/g, '')
                .replace(/^\s*\{.*?\}\s*$/gm, '')
                .replace(/^\s*\[.*?\]\s*$/gm, '')
                .replace(/\n{3,}/g, '\n\n')
                .trim();

              const finalHTML = cleanResponse 
                ? safeRenderMarkdown(cleanResponse) 
                : '<em style="color:#888">No content received</em>';

              updateTileResponseContent(tileId, finalHTML, false);

              const tile = pairs.find(t => t.id === tileId);
              if (tile) tile.response = cleanResponse || '';
              save();

              fullscreenOverlay.classList.remove('streaming');
              return;
            }

            try {
              jsonData = JSON.parse(dataStr);
            } catch (e) {
              // Not JSON → ignore (rare)
            }
          }
        }

        // If entire event was a comment → skip completely
        if (isComment) continue;

        // Process real delta content
        if (jsonData) {
          const content = jsonData.choices?.[0]?.delta?.content;
          if (content) {
            accumulatedAIResponse += content;
            updateTileResponseContent(tileId, content, true);
          }
          // Ignore tool_calls etc. silently
        }
      }
    }
  } catch (err) {
    console.error('Stream error', err);
    updateTileResponseContent(tileId, `<p style="color:red">Stream error: ${escapeHTML(err.message || String(err))}</p>`, false);
  } finally {
    // Your existing finally block (fallback cleanup)
    fullscreenOverlay.classList.remove('streaming');
    if (accumulatedAIResponse) {
      // ... same cleanup as above ...
    }
    updateCardMinHeight();
  }
}
// API fetch
async function apiFetch(path, payload) {
  const base = getBaseUrl();
  if (!base) throw new Error('API Base URL not set.');

  const url = base + path;
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    let msg = `HTTP ${res.status}`;
    try {
      const j = await res.json();
      msg = j.error || j.message || JSON.stringify(j);
    } catch {}
    throw new Error(msg);
  }

  if (res.body && typeof res.body.getReader === 'function') {
    return res.body.getReader();
  }

  const text = await res.text().catch(() => '');
  const enc = new TextEncoder();
  const chunk = enc.encode(text);
  const stream = new ReadableStream({
    start(ctrl) {
      if (chunk && chunk.length) ctrl.enqueue(chunk);
      ctrl.close();
    }
  });

  return stream.getReader();
}

// Send message
async function sendMessage() {
  const input = (userInputElement.value || '').trim();
  if (!input) return;

  const mode = modeSelectElement.value || 'chat';
  userInputElement.value = '';
  loadingIndicator.classList.add('show');

  try {
    const payload = { sessionId };
    if (mode === 'chat') {
      payload.message = input;
    } else {
      payload.prompt = input;
    }

    const path = mode === 'code' ? '/api/code' : mode === 'generate' ? '/api/generate' : '/api/chat';

    currentTileIdForStreaming = addPair({ question: input, response: '...' });

    const reader = await apiFetch(path, payload);
    await processSSEStream(reader, currentTileIdForStreaming);
  } catch (err) {
    const msg = err?.message ? err.message : String(err);

    if (currentTileIdForStreaming) {
      updateTileResponseContent(currentTileIdForStreaming, `<p style="color:red">Error: ${escapeHTML(msg)}</p>`, false);
      const tile = pairs.find(x => x.id === currentTileIdForStreaming);
      if (tile) tile.response = `Error: ${msg}`;
      save();
    } else {
      alert(msg);
    }
  } finally {
    loadingIndicator.classList.remove('show');
    currentTileIdForStreaming = null;
    updateCardMinHeight();
  }
}

// Tile actions
function deletePair(id) {
  pairs = pairs.filter(p => p.id !== id);
  const el = document.querySelector(`[data-id="${id}"]`);
  if (el) el.remove();
  save();

  if (currentFullscreenTileId === id) {
    hideFullscreen();
  }
}

function copyResponse(id) {
  const el = document.querySelector(`[data-id="${id}"] .card-back .response-content`);
  const txt = el ? (el.textContent || '') : '';
  navigator.clipboard.writeText(txt)
    .then(() => showSavedNotice('Copied!'))
    .catch(() => alert('Copy failed'));
}

function sendTileToAI(id) {
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  const resp = document.querySelector(`[data-id="${id}"] .card-back .response-content`)?.textContent || '';
  userInputElement.value = `\( {tile.question}\n\n---\n\n \){resp.slice(0, 1000)}`;
  userInputElement.focus();
}

// Fullscreen functions
function showFullscreen(id) {
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  currentFullscreenTileId = id;

  // Update all question text elements
  fullscreenQuestionTexts.forEach(el => {
    el.textContent = tile.question || '';
  });

  // Update response
  fullscreenResponseContents.forEach(el => {
    if (currentTileIdForStreaming === id && accumulatedAIResponse) {
      el.textContent = accumulatedAIResponse;
    } else {
      el.innerHTML = tile.response ? safeRenderMarkdown(tile.response) : 'No response yet';
    }
    el.scrollTop = el.scrollHeight;
  });

  fullscreenCardInner.classList.add('flipped');
  fullscreenOverlay.classList.add('show');
  fullscreenOverlay.setAttribute('aria-hidden', 'false');

  updateCardMinHeight();
}

function hideFullscreen() {
  fullscreenOverlay.classList.remove('show');
  fullscreenOverlay.classList.remove('streaming');
  fullscreenOverlay.setAttribute('aria-hidden', 'true');
  currentFullscreenTileId = null;
  fullscreenCardInner.classList.remove('flipped');
}

function flipFullscreen() {
  fullscreenCardInner.classList.toggle('flipped');
}

// Edit modal
function showEditModal(id) {
  editingTileId = id;
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  editTileIdDisplaySpan.textContent = `#${id.slice(0, 8)}`;
  editQuestionTextarea.value = tile.question || '';
  editResponseTextarea.value = tile.response || '';
  editPreviewDiv.style.display = 'none';
  editPreviewDiv.innerHTML = '';

  editModal.classList.add('show');
  editModal.setAttribute('aria-hidden', 'false');
  hideFullscreen();
}

function closeEditModal() {
  editingTileId = null;
  editModal.classList.remove('show');
  editModal.setAttribute('aria-hidden', 'true');
}

function saveEditedTile() {
  if (!editingTileId) return closeEditModal();

  const tile = pairs.find(p => p.id === editingTileId);
  if (!tile) return closeEditModal();

  tile.question = (editQuestionTextarea.value || '').trim();
  tile.response = (editResponseTextarea.value || '').trim();

  const card = gridElement.querySelector(`[data-id="${tile.id}"]`);
  if (card) {
    const questionDiv = card.querySelector('.card-front .question-div');
    if (questionDiv) questionDiv.textContent = tile.question;

    const responseDiv = card.querySelector('.card-back .response-content');
    if (responseDiv) responseDiv.innerHTML = safeRenderMarkdown(tile.response);
  }

  save();
  showSavedNotice();
  closeEditModal();

  if (currentFullscreenTileId === tile.id) {
    showFullscreen(tile.id); // Refresh fullscreen
  }
}

function toggleEditPreview() {
  if (editPreviewDiv.style.display === 'none') {
    editPreviewDiv.innerHTML = safeRenderMarkdown(editResponseTextarea.value);
    editPreviewDiv.style.display = 'block';
    editTogglePreviewBtn.textContent = 'Hide Preview';
  } else {
    editPreviewDiv.style.display = 'none';
    editTogglePreviewBtn.textContent = 'Preview';
  }
}

// Settings
function showSettings() {
  baseUrlInput.value = localStorage.getItem(STORAGE_BASEURL_KEY) || '';
  sessionIdInput.value = sessionId;
  settingsModal.classList.add('show');
  settingsModal.setAttribute('aria-hidden', 'false');
}

function closeSettings() {
  settingsModal.classList.remove('show');
  settingsModal.setAttribute('aria-hidden', 'true');
}

function saveSettings() {
  localStorage.setItem(STORAGE_BASEURL_KEY, (baseUrlInput.value || '').trim());
  closeSettings();
  showSavedNotice();
}

function exportData() {
  const data = { pairs, history, sessionId };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `mindmap-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 500);
}

function importData(file) {
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      pairs = data.pairs || [];
      history = data.history || [];
      sessionId = data.sessionId || sessionId;

      gridElement.innerHTML = '';
      pairs.forEach(renderPair);
      save();
      showSavedNotice('Imported!');
    } catch (err) {
      alert('Invalid file: ' + (err.message || err));
    }
  };
  reader.readAsText(file);
}

// Storage
function save() {
  try {
    localStorage.setItem(STORAGE_DATA_KEY, JSON.stringify({ pairs, history, sessionId }));
  } catch (e) {
    console.warn('Failed to save:', e);
  }
}

function load() {
  try {
    const raw = localStorage.getItem(STORAGE_DATA_KEY);
    if (raw) {
      const data = JSON.parse(raw);
      pairs = data.pairs || [];
      history = data.history || [];
      sessionId = data.sessionId || sessionId;
      pairs.forEach(renderPair);
    }
  } catch (e) {
    console.warn('Failed to load:', e);
  }

  const savedUrl = localStorage.getItem(STORAGE_BASEURL_KEY);
  if (savedUrl) baseUrlInput.value = savedUrl;

  const savedHeight = localStorage.getItem(STORAGE_DIVIDER_HEIGHT_KEY);
  if (savedHeight && parseFloat(savedHeight) > 2) {
    applyInputPanelHeight(parseFloat(savedHeight));
  } else {
    applyInputPanelHeight(200);
  }

  updateCardMinHeight();
}

// Panel resize
function applyInputPanelHeight(height) {
  const maxHeight = window.innerHeight * 0.8;
  const newHeight = Math.max(0, Math.min(height || 0, maxHeight));

  if (newHeight <= 2) {
    inputPanelElement.style.height = '0px';
    inputPanelElement.style.opacity = '0';
    inputPanelElement.style.overflow = 'hidden';
  } else {
    inputPanelElement.style.height = newHeight + 'px';
    inputPanelElement.style.opacity = '1';
    inputPanelElement.style.overflow = 'auto';
  }

  updateCardMinHeight();
}

let resizing = false;
let startY = 0;
let startHeight = 0;

resizeDivider.addEventListener('mousedown', e => {
  resizing = true;
  startY = e.clientY;
  startHeight = inputPanelElement.getBoundingClientRect().height;
  document.body.style.userSelect = 'none';
});

document.addEventListener('mousemove', e => {
  if (!resizing) return;
  const delta = e.clientY - startY;
  applyInputPanelHeight(startHeight + delta);
});

document.addEventListener('mouseup', () => {
  if (resizing) {
    resizing = false;
    document.body.style.userSelect = '';
    const currentHeight = inputPanelElement.getBoundingClientRect().height;
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, currentHeight);
  }
});

resizeDivider.addEventListener('touchstart', e => {
  const touch = e.touches[0];
  resizing = true;
  startY = touch.clientY;
  startHeight = inputPanelElement.getBoundingClientRect().height;
}, { passive: false });

document.addEventListener('touchmove', e => {
  if (!resizing) return;
  const touch = e.touches[0];
  const delta = touch.clientY - startY;
  applyInputPanelHeight(startHeight + delta);
}, { passive: false });

document.addEventListener('touchend', () => {
  if (resizing) {
    resizing = false;
    const currentHeight = inputPanelElement.getBoundingClientRect().height;
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, currentHeight);
  }
});

resizeDivider.addEventListener('dblclick', () => {
  const currentHeight = inputPanelElement.getBoundingClientRect().height;
  if (currentHeight <= 2) {
    applyInputPanelHeight(200);
  } else {
    applyInputPanelHeight(0);
  }
});

// Event delegation
document.addEventListener('click', e => {
  const button = e.target.closest('[data-action]');
  if (!button) return;

  e.stopPropagation();
  const action = button.dataset.action;
  const id = button.dataset.id || button.closest('.flip-card')?.dataset.id;

  switch (action) {
    case 'show-fullscreen':
      if (id) showFullscreen(id);
      break;
    case 'edit':
      if (id) showEditModal(id);
      break;
    case 'delete':
      if (id && confirm('Delete this tile?')) deletePair(id);
      break;
    case 'copy':
      if (id) copyResponse(id);
      break;
    case 'followup':
      if (id) sendTileToAI(id);
      break;
    case 'flip':
      flipFullscreen();
      break;
    case 'close':
      hideFullscreen();
      break;
  }
});

// UI listeners
document.getElementById('logoBtn').addEventListener('click', () => location.reload());
document.getElementById('settingsOpenBtn').addEventListener('click', showSettings);
document.getElementById('runTestsBtn').addEventListener('click', () => {
  try {
    const id = addPair({ question: 'self-test', response: 'ok' });
    if (!document.querySelector(`[data-id="${id}"]`)) throw new Error('render failed');
    deletePair(id);
    if (document.querySelector(`[data-id="${id}"]`)) throw new Error('delete failed');
    alert('✓ Self-tests passed');
  } catch (e) {
    alert('✖ Self-test failed: ' + e.message);
    console.error(e);
  }
});

document.getElementById('settingsSaveBtn').addEventListener('click', saveSettings);
document.getElementById('settingsCancelBtn').addEventListener('click', closeSettings);
document.getElementById('exportBtn').addEventListener('click', exportData);
document.getElementById('importFile').addEventListener('change', e => {
  const file = e.target.files?.[0];
  if (file) importData(file);
  e.target.value = '';
});

document.getElementById('sendBtn').addEventListener('click', sendMessage);
document.getElementById('editSaveBtn').addEventListener('click', saveEditedTile);
document.getElementById('editCancelBtn').addEventListener('click', closeEditModal);
document.getElementById('editTogglePreview').addEventListener('click', toggleEditPreview);

document.getElementById('composeOpenBtn').addEventListener('click', () => {
  composeInput.value = userInputElement.value || '';
  composeModal.classList.add('show');
  composeModal.setAttribute('aria-hidden', 'false');
});
document.getElementById('composeCancelBtn').addEventListener('click', () => {
  composeModal.classList.remove('show');
  composeModal.setAttribute('aria-hidden', 'true');
});
document.getElementById('composeSendBtn').addEventListener('click', () => {
  userInputElement.value = composeInput.value;
  composeModal.classList.remove('show');
  composeModal.setAttribute('aria-hidden', 'true');
  sendMessage();
});

// Close modals on outside click
document.addEventListener('click', e => {
  if (e.target === settingsModal) closeSettings();
  if (e.target === editModal) closeEditModal();
  if (e.target === fullscreenOverlay) hideFullscreen();
  if (e.target === composeModal) {
    composeModal.classList.remove('show');
    composeModal.setAttribute('aria-hidden', 'true');
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    if (fullscreenOverlay.classList.contains('show')) hideFullscreen();
    else if (editModal.classList.contains('show')) closeEditModal();
    else if (settingsModal.classList.contains('show')) closeSettings();
    else if (composeModal.classList.contains('show')) {
      composeModal.classList.remove('show');
      composeModal.setAttribute('aria-hidden', 'true');
    }
  }

  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    if (document.activeElement === userInputElement || document.activeElement === composeInput) {
      e.preventDefault();
      sendMessage();
    }
  }
});

function showSavedNotice(text = 'Saved!') {
  savedNotice.textContent = text;
  savedNotice.classList.add('show');
  setTimeout(() => savedNotice.classList.remove('show'), 2000);
}

// Initialize
load();

window.MindMap = { addPair, pairs };
</script>
</body>
</html>
