<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ai-Ndraft</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/responsivevoice@1.0.0/responsivevoice.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        :root {
            --primary: #c41e3a;
            --bg: #121212;
            --card-bg: #1e1e1e;
            --text: #f5f5f5;
            --border: #333;
            --shadow: 0 4px 16px rgba(196,30,58,0.2);
            --radius: 16px;
            --card-min-height: 220px;
        }

        [data-theme="light"] {
            --bg: #f8f9fa;
            --card-bg: #ffffff;
            --text: #222;
            --border: #ddd;
            --shadow: 0 4px 16px rgba(196,30,58,0.15);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding-top: 70px;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            padding: 16px;
            padding-bottom: 120px;
        }

        .flip-card {
            min-height: var(--card-min-height);
            perspective: 1000px;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
            position: relative;
        }

        .flip-card.new {
            opacity: 0;
            transform: scale(0.95);
            animation: appear 0.4s ease forwards;
        }

        @keyframes appear {
            to { opacity: 1; transform: scale(1); }
        }

        .flip-card-inner {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flipped .flip-card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            inset: 0;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            padding: 16px;
            overflow-y: auto;
            font-size: 15px;
            line-height: 1.6;
            background: var(--card-bg);
            color: var(--text);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .card-back {
            transform: rotateY(180deg);
        }

        .card-header {
            position: sticky;
            top: 0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding-bottom: 8px;
            background: inherit;
            z-index: 10;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
        }

        .card-actions button {
            background: none;
            border: none;
            color: var(--text);
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            opacity: 0.7;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .card-actions button:hover {
            opacity: 1;
            background: rgba(196,30,58,0.1);
        }

        .flip-card.selected {
            outline: 4px solid var(--primary);
            outline-offset: -4px;
            transform: scale(1.02);
        }

        #selectionBar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border-bottom: 1px solid var(--border);
            padding: 12px;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow);
        }

        #selectionBar.active {
            display: flex;
        }

        #mergeSelected {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        #mergeSelected:hover {
            background: #a1172f;
        }

        .fullscreen-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            z-index: 10000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

        .fullscreen-overlay.active {
            display: flex;
        }

        .fullscreen-card {
            width: 95%;
            max-width: 1000px;
            height: 95vh;
            background: var(--card-bg);
            border-radius: 20px;
            overflow: hidden;
            perspective: 2000px;
            border: 1px solid var(--border);
            color: var(--text);
            position: relative;
        }

        .fullscreen-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .fullscreen-overlay.flipped .fullscreen-inner {
            transform: rotateY(180deg);
        }

        .fullscreen-face {
            position: absolute;
            inset: 0;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            background: var(--card-bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 24px;
            overflow-y: auto;
        }

        .fullscreen-back {
            transform: rotateY(180deg);
        }

        .fullscreen-header {
            position: sticky;
            top: 0;
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--card-bg);
            z-index: 10;
        }

        .fullscreen-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            opacity: 0.7;
            color: var(--text);
            transition: all 0.2s;
        }

        .fullscreen-btn:hover {
            opacity: 1;
        }

        .fullscreen-content {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.7;
        }

        .streaming {
            text-align: center;
            color: #aaa;
            padding: 20px;
            margin-top: 20px;
        }

        .cursor {
            display: inline-block;
            width: 3px;
            height: 1em;
            background: currentColor;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        #inputPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border-top: 1px solid var(--border);
            padding: 16px;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 100;
        }

        #userInput {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 16px;
            background: var(--bg);
            color: var(--text);
            transition: all 0.2s;
        }

        #userInput:focus {
            outline: none;
            border-color: var(--primary);
        }

        #sendBtn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 100px;
            justify-content: center;
            transition: all 0.2s;
        }

        #sendBtn:hover {
            background: #a1172f;
            transform: translateY(-2px);
        }

        #moreBtn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--border);
            font-size: 24px;
            cursor: pointer;
            box-shadow: var(--shadow);
            z-index: 900;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        #moreBtn:hover {
            transform: rotate(90deg);
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 24px;
            width: 90%;
            max-width: 600px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            color: var(--text);
            max-height: 90vh;
            overflow-y: auto;
        }

        textarea {
            width: 100%;
            min-height: 180px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: inherit;
            font-size: 15px;
            background: var(--bg);
            color: var(--text);
            resize: vertical;
            margin-bottom: 16px;
            transition: all 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .modal-actions button {
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            border: none;
            font-size: 16px;
            min-width: 50px;
            transition: all 0.2s;
        }

        .modal-actions button.primary {
            background: var(--primary);
            color: white;
        }

        .modal-actions button.primary:hover {
            background: #a1172f;
        }

        .modal-actions button.secondary {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }

        .modal-actions button.secondary:hover {
            background: rgba(196,30,58,0.1);
        }

        #cardMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 16px;
            display: none;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            border: 1px solid var(--border);
        }

        #cardMenu.active {
            display: flex;
        }

        .menu-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 12px;
            border-radius: 12px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
            transition: all 0.2s;
        }

        .menu-btn:hover {
            background: rgba(196,30,58,0.1);
            transform: scale(1.1);
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            display: none;
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        #loading.show {
            display: block;
        }

        #brandPlaceholder {
            position: fixed;
            top: 20px;
            left: 16px;
            z-index: 100;
            pointer-events: none;
            font-size: 24px;
            font-weight: 900;
            color: rgba(196,30,58,0.3);
            transform: rotate(-12deg);
            user-select: none;
        }

        .style-panel {
            position: fixed;
            bottom: 80px;
            right: 80px;
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            z-index: 950;
            width: 320px;
            display: none;
            flex-direction: column;
            gap: 16px;
        }

        .style-panel.active {
            display: flex;
        }

        .style-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .style-section h4 {
            font-size: 14px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .style-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .style-btn {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .style-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .color-picker label {
            font-size: 12px;
            min-width: 80px;
        }

        .color-picker input {
            width: 60px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-picker input:hover {
            transform: scale(1.05);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-container label {
            font-size: 12px;
            min-width: 80px;
        }

        .slider-container input {
            flex: 1;
        }

        .advanced-styles {
            display: none;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .advanced-styles.active {
            display: flex;
        }

        .toggle-advanced {
            font-size: 12px;
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
            align-self: flex-end;
        }

        .css-editor {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: var(--bg);
            color: var(--text);
            resize: vertical;
        }
    </style>
</head>
<body>
    <div id="brandPlaceholder">ai-Ndraft</div>

    <div id="selectionBar">
        <button id="cancelSelect"><i class="fas fa-times"></i></button>
        <span id="selectCount">0</span>
        <button id="mergeSelected"><i class="fas fa-layer-group"></i> Combine</button>
    </div>

    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="fullscreen-card">
            <div class="fullscreen-inner">
                <div class="fullscreen-face">
                    <div class="fullscreen-header">
                        <button class="fullscreen-btn fullscreen-flip"><i class="fas fa-sync-alt"></i></button>
                        <button class="fullscreen-btn fullscreen-close"><i class="fas fa-times"></i></button>
                    </div>
                    <div class="fullscreen-content" id="fsQuestion"></div>
                </div>
                <div class="fullscreen-face fullscreen-back">
                    <div class="fullscreen-header">
                        <button class="fullscreen-btn fullscreen-flip"><i class="fas fa-sync-alt"></i></button>
                        <button class="fullscreen-btn fullscreen-close"><i class="fas fa-times"></i></button>
                    </div>
                    <div class="fullscreen-content" id="fsResponse"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="grid"></div>

    <div id="loading">Processing...</div>

    <button id="moreBtn"><i class="fas fa-cog"></i></button>

    <div class="modal" id="moreModal">
        <div class="modal-content">
            <h3>Settings</h3>
            <div class="modal-actions">
                <button id="toggleThemeBtn" title="Toggle Theme"><i class="fas fa-moon"></i></button>
                <button id="toggleASRBtn" title="Toggle Speech Input"><i class="fas fa-microphone"></i></button>
                <button id="toggleTTSBtn" title="Toggle Auto Read"><i class="fas fa-volume-up"></i></button>
                <button id="modalExport" title="Export"><i class="fas fa-file-export"></i></button>
                <button id="modalImport" title="Import"><i class="fas fa-file-import"></i></button>
                <button id="modalClose" class="secondary" title="Close"><i class="fas fa-times"></i></button>
            </div>
            <input type="file" id="fileInput" style="display:none;" accept=".json">
        </div>
    </div>

    <div id="cardMenu">
        <button class="menu-btn" data-action="continue" title="Continue"><i class="fas fa-redo"></i></button>
        <button class="menu-btn" data-action="copy" title="Copy Response"><i class="fas fa-copy"></i></button>
        <button class="menu-btn" data-action="ai-edit" title="AI Edit"><i class="fas fa-magic"></i></button>
        <button class="menu-btn" data-action="ai-theme" title="AI Theme"><i class="fas fa-palette"></i></button>
        <button class="menu-btn" data-action="manual-edit-response" title="Edit Response"><i class="fas fa-edit"></i></button>
        <button class="menu-btn" data-action="manual-edit-question" title="Edit Question"><i class="fas fa-pencil-alt"></i></button>
        <button class="menu-btn" data-action="style" title="Style Card"><i class="fas fa-paint-brush"></i></button>
        <button class="menu-btn" data-action="split" title="Split"><i class="fas fa-cut"></i></button>
        <button class="menu-btn" data-action="fullscreen" title="Fullscreen"><i class="fas fa-expand"></i></button>
        <button class="menu-btn" data-action="delete" title="Delete"><i class="fas fa-trash"></i></button>
    </div>

    <div class="style-panel" id="stylePanel">
        <div class="style-section">
            <h4>Text Style</h4>
            <div class="style-controls">
                <button class="style-btn" data-style="bold"><i class="fas fa-bold"></i> Bold</button>
                <button class="style-btn" data-style="italic"><i class="fas fa-italic"></i> Italic</button>
                <button class="style-btn" data-style="underline"><i class="fas fa-underline"></i> Underline</button>
                <button class="style-btn" data-style="strikethrough"><i class="fas fa-strikethrough"></i> Strike</button>
            </div>
        </div>

        <div class="style-section">
            <h4>Text Size</h4>
            <div class="style-controls">
                <button class="style-btn" data-style="text-sm">Small</button>
                <button class="style-btn" data-style="text-base">Normal</button>
                <button class="style-btn" data-style="text-lg">Large</button>
                <button class="style-btn" data-style="text-xl">X-Large</button>
            </div>
        </div>

        <div class="style-section">
            <h4>Colors</h4>
            <div class="color-picker">
                <label for="textColorPicker">Text:</label>
                <input type="color" id="textColorPicker" value="#f5f5f5">
            </div>
            <div class="color-picker">
                <label for="bgColorPicker">Background:</label>
                <input type="color" id="bgColorPicker" value="#1e1e1e">
            </div>
            <div class="color-picker">
                <label for="borderColorPicker">Border:</label>
                <input type="color" id="borderColorPicker" value="#333">
            </div>
        </div>

        <div class="style-section">
            <h4>Spacing</h4>
            <div class="slider-container">
                <label for="paddingSlider">Padding:</label>
                <input type="range" id="paddingSlider" min="8" max="32" value="16">
                <span id="paddingValue">16px</span>
            </div>
            <div class="slider-container">
                <label for="borderRadiusSlider">Radius:</label>
                <input type="range" id="borderRadiusSlider" min="4" max="24" value="16">
                <span id="borderRadiusValue">16px</span>
            </div>
            <div class="slider-container">
                <label for="borderWidthSlider">Border:</label>
                <input type="range" id="borderWidthSlider" min="0" max="4" value="1">
                <span id="borderWidthValue">1px</span>
            </div>
        </div>

        <div class="style-section">
            <span class="toggle-advanced" id="toggleAdvanced">+ Advanced CSS</span>
            <div class="advanced-styles" id="advancedStyles">
                <textarea class="css-editor" id="customCSS" placeholder="Enter custom CSS rules..."></textarea>
            </div>
        </div>

        <div class="modal-actions">
            <button id="applyStyles" class="primary"><i class="fas fa-check"></i> Apply</button>
            <button id="cancelStyles" class="secondary"><i class="fas fa-times"></i> Cancel</button>
        </div>
    </div>

    <div class="modal" id="textEditorModal">
        <div class="modal-content">
            <h3>Edit</h3>
            <textarea id="textEditorArea"></textarea>
            <div class="modal-actions">
                <button id="textEditorCancel" class="secondary"><i class="fas fa-times"></i></button>
                <button id="textEditorSave" class="primary"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div class="modal" id="mergePromptModal">
        <div class="modal-content">
            <h3>Merge Cards</h3>
            <textarea id="mergePromptText" placeholder="Optional instructions"></textarea>
            <div class="modal-actions">
                <button id="mergePromptCancel" class="secondary"><i class="fas fa-times"></i></button>
                <button id="mergePromptConfirm" class="primary"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div class="modal" id="continuePromptModal">
        <div class="modal-content">
            <h3>Continue</h3>
            <textarea id="continuePromptText" placeholder="Optional instructions"></textarea>
            <div class="modal-actions">
                <button id="continuePromptCancel" class="secondary"><i class="fas fa-times"></i></button>
                <button id="continuePromptConfirm" class="primary"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div class="modal" id="splitPromptModal">
        <div class="modal-content">
            <h3>Split</h3>
            <textarea id="splitPromptText" placeholder="Optional instructions"></textarea>
            <div class="modal-actions">
                <button id="splitPromptCancel" class="secondary"><i class="fas fa-times"></i></button>
                <button id="splitPromptConfirm" class="primary"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <div class="modal" id="editPromptModal">
        <div class="modal-content">
            <h3>AI Edit</h3>
            <textarea id="editPromptText" placeholder="What changes?"></textarea>
            <div class="modal-actions">
                <button id="editPromptCancel" class="secondary"><i class="fas fa-times"></i></button>
                <button id="editPromptConfirm" class="primary"><i class="fas fa-check"></i></button>
            </div>
        </div>
    </div>

    <!-- AI Theme Modal -->
    <div class="modal" id="aiThemeModal">
        <div class="modal-content">
            <h3>AI Theme This Card</h3>
            <textarea id="aiThemePrompt" placeholder="Describe any theme (Kill Bill, cyberpunk, vintage Polaroid, luxury gold, vaporwave...)"></textarea>
            <div class="modal-actions">
                <button class="secondary" id="cancelAITheme">Cancel</button>
                <button class="primary" id="applyAITheme">Apply</button>
            </div>
        </div>
    </div>

    <div id="inputPanel">
        <input type="text" id="userInput" placeholder="What's up? ðŸ«“">
        <button id="sendBtn"><i class="fas fa-paper-plane"></i> Send</button>
    </div>

<script>
const PROXY_URL = "https://ai-proxy.ai-n.workers.dev/api/generate";

const DEFAULT_THEME = {
    name: 'ai-Ndraft',
    primary: '#c41e3a',
    bg: '#121212',
    cardBg: '#1e1e1e',
    text: '#f5f5f5',
    border: '#333'
};

const SYSTEM_PROMPT = `You are a helpful, casual AI assistant.

You can ALSO control styling using special commands that must appear BEFORE the visible text. Users will usually talk in plain language ("make it xtina-red", "white label this"), you decide which commands to emit.

Page-wide theme (affects whole app shell):
- !page-theme:name,bg,cardBg,text,border,primary!
  Example:
  !page-theme:xtina,#2b0004,#1a0003,#ffe8f0,#552233,#ff1744!

Per-card styling (only affects that answer card):
- !bg-color:hex!          e.g. !bg-color:#2b0004!
- !text-color:hex!        e.g. !text-color:#ffe8f0!
- !border-color:hex!
- !padding:px!
- !border-radius:px!
- !font-size:px!
- !font-weight:value!     (normal,bold)
- !font-style:value!      (normal,italic)
- !text-decoration:value! (none,underline,line-through)
- !custom-css:rules!      (simple CSS fragment, the app will scope it)

User language is plain:
- "xtina red, pale text"  -> you pick matching colors.
- "white-label neutral"   -> light bg, white cards, dark text, generic name.
- "sticky note"           -> yellow card, black text, small rounded corners.

ALWAYS put the style commands at the top of your response, then a blank line, then the markdown content. Respond in clean markdown when helpful.`;

class App {
    constructor() {
        this.cards = [];
        this.sessionId = "s-" + Date.now();
        this.streamingId = null;
        this.selected = new Set();
        this.selectMode = false;
        this.fullscreenId = null;
        this.currentMenuId = null;
        this.currentContinueId = null;
        this.currentSplitId = null;
        this.currentEditId = null;
        this.editingCardId = null;
        this.editingField = null;
        this.currentStylingCard = null;
        this.decoder = new TextDecoder();
        this.recognizing = false;
        this.recognition = null;
        this.aiSpeechEnabled = true;
        this.autoReadEnabled = false;
        this.theme = { ...DEFAULT_THEME };
        this.init();
    }

    init() {
        this.load();
        this.bind();
        this.initASR();
        this.updateTalkButton();
        this.setupSliders();

        const themePref = localStorage.getItem('themeMode') || 'dark';
        document.body.dataset.theme = themePref;

        const savedASR = localStorage.getItem('aiSpeechEnabled');
        if (savedASR !== null) {
            this.aiSpeechEnabled = savedASR === 'true';
        }

        const savedAutoRead = localStorage.getItem('autoReadEnabled');
        if (savedAutoRead !== null) {
            this.autoReadEnabled = savedAutoRead === 'true';
        }

        // Apply theme on first load
        this.applyTheme(this.theme);
    }

    setupSliders() {
        const updateSliderValue = (sliderId, valueId) => {
            const slider = document.getElementById(sliderId);
            const value = document.getElementById(valueId);
            value.textContent = slider.value + 'px';
            slider.oninput = () => {
                value.textContent = slider.value + 'px';
            };
        };

        updateSliderValue('paddingSlider', 'paddingValue');
        updateSliderValue('borderRadiusSlider', 'borderRadiusValue');
        updateSliderValue('borderWidthSlider', 'borderWidthValue');
    }

    initASR() {
        if ("webkitSpeechRecognition" in window) {
            this.recognition = new webkitSpeechRecognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = false;
            this.recognition.lang = "en-US";

            this.recognition.onstart = () => {
                this.recognizing = true;
                this.updateTalkButton();
            };

            this.recognition.onend = () => {
                this.recognizing = false;
                this.updateTalkButton();
            };

            this.recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                const inputEl = document.getElementById('userInput');
                inputEl.value = transcript;
                this.maybeShowHint(transcript);
                this.send();
            };

            this.recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                this.recognizing = false;
                this.updateTalkButton();
            };
        }
    }

    updateTalkButton() {
        const talkBtn = document.getElementById('sendBtn');
        if (this.recognizing) {
            talkBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
        } else if (this.aiSpeechEnabled && "webkitSpeechRecognition" in window) {
            talkBtn.innerHTML = '<i class="fas fa-microphone"></i> Speak';
        } else {
            talkBtn.innerHTML = '<i class="fas fa-paper-plane"></i> Send';
        }
    }

    // tiny "hidden onboarding": if user types 'brand', suggest what they can do
    maybeShowHint(text) {
        const t = text.toLowerCase();
        if (t.includes('brand') || t.includes('theme')) {
            const grid = document.getElementById('grid');
            const hint = document.createElement('div');
            hint.style.fontSize = '12px';
            hint.style.opacity = '0.7';
            hint.style.margin = '4px 8px';
            hint.textContent = 'Tip: you can say things like "switch this to xtina red branding" or "make this white-label neutral" and the AI will restyle the page and cards.';
            grid.prepend(hint);
            setTimeout(() => hint.remove(), 8000);
        }
    }

    bind() {
        document.getElementById('sendBtn').onclick = () => {
            if (this.recognizing) {
                this.recognition.stop();
            } else if (this.aiSpeechEnabled && "webkitSpeechRecognition" in window) {
                this.recognition.start();
            } else {
                this.send();
            }
        };

        const inputEl = document.getElementById('userInput');
        inputEl.onkeydown = e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.send();
            }
        };
        inputEl.oninput = () => this.maybeShowHint(inputEl.value);

        document.getElementById('moreBtn').onclick = () => {
            document.getElementById('moreModal').classList.add('active');
        };

        document.getElementById('modalClose').onclick = () => {
            document.getElementById('moreModal').classList.remove('active');
        };

        document.getElementById('toggleThemeBtn').onclick = () => {
            const current = document.body.dataset.theme;
            const newThemeMode = current === 'dark' ? 'light' : 'dark';
            document.body.dataset.theme = newThemeMode;
            localStorage.setItem('themeMode', newThemeMode);
        };

        document.getElementById('toggleASRBtn').onclick = () => {
            this.aiSpeechEnabled = !this.aiSpeechEnabled;
            localStorage.setItem('aiSpeechEnabled', this.aiSpeechEnabled);
            this.updateTalkButton();
        };

        document.getElementById('toggleTTSBtn').onclick = () => {
            this.autoReadEnabled = !this.autoReadEnabled;
            localStorage.setItem('autoReadEnabled', this.autoReadEnabled);
            const btn = document.getElementById('toggleTTSBtn');
            btn.style.opacity = this.autoReadEnabled ? '1' : '0.5';
        };

        document.getElementById('modalExport').onclick = () => this.export();
        document.getElementById('modalImport').onclick = () => document.getElementById('fileInput').click();
        document.getElementById('fileInput').onchange = e => this.import(e);

        document.querySelectorAll('.fullscreen-close').forEach(b => {
            b.onclick = () => this.closeFS();
        });

        document.querySelectorAll('.fullscreen-flip').forEach(b => {
            b.onclick = () => document.getElementById('fullscreenOverlay').classList.toggle('flipped');
        });

        document.getElementById('cancelSelect').onclick = () => this.exitSelect();
        document.getElementById('mergeSelected').onclick = () => {
            document.getElementById('mergePromptModal').classList.add('active');
        };

        document.getElementById('mergePromptCancel').onclick = () => {
            document.getElementById('mergePromptModal').classList.remove('active');
        };

        document.getElementById('mergePromptConfirm').onclick = () => this.merge();

        document.getElementById('continuePromptCancel').onclick = () => {
            document.getElementById('continuePromptModal').classList.remove('active');
        };

        document.getElementById('continuePromptConfirm').onclick = () => this.continue();

        document.getElementById('splitPromptCancel').onclick = () => {
            document.getElementById('splitPromptModal').classList.remove('active');
        };

        document.getElementById('splitPromptConfirm').onclick = () => this.split();

        document.getElementById('editPromptCancel').onclick = () => {
            document.getElementById('editPromptModal').classList.remove('active');
        };

        document.getElementById('editPromptConfirm').onclick = () => this.performEdit();

        document.getElementById('textEditorCancel').onclick = () => {
            document.getElementById('textEditorModal').classList.remove('active');
        };

        document.getElementById('textEditorSave').onclick = () => this.saveManualEdit();

        document.getElementById('cardMenu').onclick = e => {
            const btn = e.target.closest('.menu-btn');
            if (btn) {
                const action = btn.dataset.action;
                if (action.startsWith('manual-edit-')) {
                    const field = action === 'manual-edit-question' ? 'q' : 'r';
                    this.editText(this.currentMenuId, field);
                } else if (action === 'style') {
                    this.showStylePanel(this.currentMenuId);
                } else {
                    this.handle(action);
                }
                document.getElementById('cardMenu').classList.remove('active');
            }
        };

        document.getElementById('applyStyles').onclick = () => this.applyStyles();
        document.getElementById('cancelStyles').onclick = () => this.hideStylePanel();

        document.getElementById('toggleAdvanced').onclick = () => {
            document.getElementById('advancedStyles').classList.toggle('active');
        };

        document.querySelectorAll('.style-btn').forEach(btn => {
            btn.onclick = () => {
                btn.classList.toggle('active');
            };
        });
    }

    // Global theme: apply to CSS vars + brand text
    applyTheme(theme) {
        this.theme = { ...(this.theme || {}), ...theme };

        document.documentElement.style.setProperty('--primary', this.theme.primary || DEFAULT_THEME.primary);
        document.documentElement.style.setProperty('--bg', this.theme.bg || DEFAULT_THEME.bg);
        document.documentElement.style.setProperty('--card-bg', this.theme.cardBg || DEFAULT_THEME.cardBg);
        document.documentElement.style.setProperty('--text', this.theme.text || DEFAULT_THEME.text);
        document.documentElement.style.setProperty('--border', this.theme.border || DEFAULT_THEME.border);

        const brand = document.getElementById('brandPlaceholder');
        if (brand && this.theme.name) {
            brand.textContent = `ðŸ«“${this.theme.name}ðŸ«“`;
        }
    }

    showStylePanel(cardId) {
        this.currentStylingCard = cardId;
        const card = this.cards.find(c => c.id === cardId);
        if (!card) return;

        const panel = document.getElementById('stylePanel');

        document.querySelectorAll('.style-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('textColorPicker').value = '#f5f5f5';
        document.getElementById('bgColorPicker').value = '#1e1e1e';
        document.getElementById('borderColorPicker').value = '#333';
        document.getElementById('paddingSlider').value = 16;
        document.getElementById('paddingValue').textContent = '16px';
        document.getElementById('borderRadiusSlider').value = 16;
        document.getElementById('borderRadiusValue').textContent = '16px';
        document.getElementById('borderWidthSlider').value = 1;
        document.getElementById('borderWidthValue').textContent = '1px';
        document.getElementById('customCSS').value = '';

        if (card.styles) {
            if (card.styles.fontWeight === 'bold') {
                document.querySelector('.style-btn[data-style="bold"]').classList.add('active');
            }
            if (card.styles.fontStyle === 'italic') {
                document.querySelector('.style-btn[data-style="italic"]').classList.add('active');
            }
            if (card.styles.textDecoration === 'underline') {
                document.querySelector('.style-btn[data-style="underline"]').classList.add('active');
            }
            if (card.styles.textDecoration === 'line-through') {
                document.querySelector('.style-btn[data-style="strikethrough"]').classList.add('active');
            }

            if (card.styles.fontSize) {
                const sizeMap = {
                    '12px': 'text-sm',
                    '15px': 'text-base',
                    '18px': 'text-lg',
                    '21px': 'text-xl'
                };
                const sizeClass = sizeMap[card.styles.fontSize];
                if (sizeClass) {
                    document.querySelector(`.style-btn[data-style="${sizeClass}"]`)?.classList.add('active');
                }
            }

            if (card.styles.color) {
                document.getElementById('textColorPicker').value = card.styles.color;
            }
            if (card.styles.backgroundColor) {
                document.getElementById('bgColorPicker').value = card.styles.backgroundColor;
            }
            if (card.styles.borderColor) {
                document.getElementById('borderColorPicker').value = card.styles.borderColor;
            }

            if (card.styles.padding) {
                const padding = parseInt(card.styles.padding);
                document.getElementById('paddingSlider').value = padding;
                document.getElementById('paddingValue').textContent = padding + 'px';
            }
            if (card.styles.borderRadius) {
                const radius = parseInt(card.styles.borderRadius);
                document.getElementById('borderRadiusSlider').value = radius;
                document.getElementById('borderRadiusValue').textContent = radius + 'px';
            }
            if (card.styles.borderWidth) {
                const width = parseInt(card.styles.borderWidth);
                document.getElementById('borderWidthSlider').value = width;
                document.getElementById('borderWidthValue').textContent = width + 'px';
            }

            if (card.styles.customCSS) {
                document.getElementById('customCSS').value = card.styles.customCSS;
            }
        }

        const cardEl = document.querySelector(`[data-id="${cardId}"]`);
        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            panel.style.top = `${rect.top + window.scrollY}px`;
            panel.style.left = `${rect.right + window.scrollX + 10}px`;
        }

        panel.classList.add('active');
    }

    hideStylePanel() {
        document.getElementById('stylePanel').classList.remove('active');
        this.currentStylingCard = null;
    }

    applyStyles() {
        if (!this.currentStylingCard) return;

        const card = this.cards.find(c => c.id === this.currentStylingCard);
        if (!card) return;

        const styles = {
            fontWeight: document.querySelector('.style-btn[data-style="bold"]').classList.contains('active') ? 'bold' : 'normal',
            fontStyle: document.querySelector('.style-btn[data-style="italic"]').classList.contains('active') ? 'italic' : 'normal',
            textDecoration: document.querySelector('.style-btn[data-style="underline"]').classList.contains('active') ? 'underline' :
                document.querySelector('.style-btn[data-style="strikethrough"]').classList.contains('active') ? 'line-through' : 'none',
            fontSize: document.querySelector('.style-btn[data-style="text-sm"]').classList.contains('active') ? '12px' :
                document.querySelector('.style-btn[data-style="text-lg"]').classList.contains('active') ? '18px' :
                document.querySelector('.style-btn[data-style="text-xl"]').classList.contains('active') ? '21px' : '15px',
            color: document.getElementById('textColorPicker').value,
            backgroundColor: document.getElementById('bgColorPicker').value,
            borderColor: document.getElementById('borderColorPicker').value,
            padding: document.getElementById('paddingSlider').value + 'px',
            borderRadius: document.getElementById('borderRadiusSlider').value + 'px',
            borderWidth: document.getElementById('borderWidthSlider').value + 'px',
            borderStyle: 'solid',
            customCSS: document.getElementById('customCSS').value
        };

        card.styles = styles;
        this.updateCardStyles(this.currentStylingCard, styles);
        this.save();
        this.hideStylePanel();
    }

    updateCardStyles(cardId, styles) {
        const cardEl = document.querySelector(`[data-id="${cardId}"]`);
        if (!cardEl) return;

        const faces = cardEl.querySelectorAll('.card-face');
        const cardInner = cardEl.querySelector('.flip-card-inner');

        faces.forEach(face => {
            face.style.fontWeight = styles.fontWeight || '';
            face.style.fontStyle = styles.fontStyle || '';
            face.style.textDecoration = styles.textDecoration === 'none' ? '' : (styles.textDecoration || '');
            face.style.fontSize = styles.fontSize || '';

            if (styles.color) face.style.color = styles.color;
            if (styles.backgroundColor) face.style.backgroundColor = styles.backgroundColor;
        });

        if (styles.borderColor) cardEl.style.borderColor = styles.borderColor;
        if (styles.borderWidth) cardEl.style.borderWidth = styles.borderWidth;
        if (styles.borderStyle) cardEl.style.borderStyle = styles.borderStyle;
        if (styles.borderRadius) cardEl.style.borderRadius = styles.borderRadius;

        if (cardInner && styles.padding) {
            cardInner.style.padding = styles.padding;
        }

        if (styles.customCSS) {
            const styleId = `custom-style-${cardId}`;
            let styleEl = document.getElementById(styleId);

            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
            }

            styleEl.textContent = `
                [data-id="${cardId}"] ${styles.customCSS}
            `;
        }
    }

    // parse AI commands -> card styles + optional page theme
    parseStyleCommands(text) {
        const styles = {};
        let themeUpdate = null;

        const cmdRegex = /!(bg-color|text-color|border-color|padding|border-radius|font-size|font-weight|font-style|text-decoration|custom-css|page-theme):([^!]+)!/gi;

        let match;
        while ((match = cmdRegex.exec(text)) !== null) {
            const [, prop, rawValue] = match;
            const value = rawValue.trim();

            switch (prop) {
                case 'page-theme': {
                    const [name, bg, cardBg, textColor, border, primary] = value.split(',').map(v => v.trim());
                    themeUpdate = {
                        name: name || this.theme.name,
                        bg: bg || this.theme.bg,
                        cardBg: cardBg || this.theme.cardBg,
                        text: textColor || this.theme.text,
                        border: border || this.theme.border,
                        primary: primary || this.theme.primary
                    };
                    break;
                }
                case 'bg-color':
                    styles.backgroundColor = value;
                    break;
                case 'text-color':
                    styles.color = value;
                    break;
                case 'border-color':
                    styles.borderColor = value;
                    styles.borderStyle = styles.borderStyle || 'solid';
                    styles.borderWidth = styles.borderWidth || '1px';
                    break;
                case 'padding':
                    styles.padding = value.endsWith('px') ? value : `${value}px`;
                    break;
                case 'border-radius':
                    styles.borderRadius = value.endsWith('px') ? value : `${value}px`;
                    break;
                case 'font-size':
                    styles.fontSize = value.endsWith('px') ? value : `${value}px`;
                    break;
                case 'font-weight':
                    styles.fontWeight = value;
                    break;
                case 'font-style':
                    styles.fontStyle = value;
                    break;
                case 'text-decoration':
                    styles.textDecoration = value;
                    break;
                case 'custom-css':
                    styles.customCSS = value;
                    break;
            }
        }

        const cleanText = text.replace(cmdRegex, '').trim();
        return { styles, themeUpdate, cleanText };
    }

    async send() {
        const inputEl = document.getElementById('userInput');
        const input = inputEl.value.trim();
        if (!input) return;
        this.maybeShowHint(input);
        inputEl.value = '';

        const id = this.add({ q: input, r: '...' }, true);
        this.streamingId = id;
        await this.request(input);
    }

    async request(prompt) {
        try {
            document.getElementById('loading').classList.add('show');
            const payload = { sessionId: this.sessionId, prompt: SYSTEM_PROMPT + "\n\nUser: " + prompt };
            const reader = await this.fetchProxy(payload);
            await this.stream(reader);
        } catch (e) {
            this.update(this.streamingId, `<p style="color:red">Error: ${e.message}</p>`);
        } finally {
            document.getElementById('loading').classList.remove('show');
            this.streamingId = null;
        }
    }

    async fetchProxy(payload) {
        const res = await fetch(PROXY_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(await res.text().catch(() => res.statusText));
        return res.body.getReader();
    }

    async stream(reader) {
        let buffer = '', acc = '';
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += this.decoder.decode(value, { stream: true });
            const parts = buffer.split('\n\n');
            buffer = parts.pop() || '';
            for (const part of parts) {
                const line = part.split('\n').find(l => l.startsWith('data:'));
                if (!line) continue;
                const data = line.slice(6).trim();
                if (data === '[DONE]') {
                    const clean = acc.trim();
                    this.finalize(this.streamingId, clean);
                    return;
                }
                try {
                    const json = JSON.parse(data);
                    const c = json.choices?.[0]?.delta?.content;
                    if (c) {
                        acc += c;
                        this.update(this.streamingId, this.md(acc));
                    }
                } catch {}
            }
        }
    }

    finalize(id, text) {
        const { styles, themeUpdate, cleanText } = this.parseStyleCommands(text);
        const html = cleanText ? this.md(cleanText) : '<em>Empty</em>';

        this.update(id, html);

        const card = this.cards.find(c => c.id === id);
        if (card) {
            card.r = cleanText;
            card.styles = { ...(card.styles || {}), ...styles };
            if (Object.keys(card.styles).length > 0) {
                this.updateCardStyles(id, card.styles);
            }
        }

        if (themeUpdate) {
            this.applyTheme(themeUpdate);
        }

        this.save();

        if (this.autoReadEnabled) {
            setTimeout(() => this.readCard(id), 500);
        }
    }

    update(id, html) {
        const gridEl = document.querySelector(`[data-id="${id}"] .response-content`);
        const fsEl = document.getElementById('fsResponse');
        const fullHtml = html + (this.streamingId === id ? '<div class="streaming"><span class="cursor"></span></div>' : '');

        if (gridEl) {
            gridEl.innerHTML = fullHtml;
            gridEl.scrollTop = gridEl.scrollHeight;
        }
        if (this.fullscreenId === id && fsEl) {
            fsEl.innerHTML = fullHtml;
            fsEl.scrollTop = fsEl.scrollHeight;
        }
    }

    add(data, fs = false) {
        const id = crypto.randomUUID();
        const card = { id, q: data.q, r: data.r || '', styles: data.styles || {} };
        this.cards.push(card);
        this.render(card, true);
        if (fs) this.openFS(id, true);
        this.save();
        return id;
    }

    render(card, newCard = false) {
        const el = document.createElement('div');
        el.className = `flip-card ${newCard ? 'new' : ''}`;
        el.dataset.id = card.id;

        const rhtml = (card.r === '...')
            ? '<div class="streaming"><span class="cursor"></span></div>'
            : this.md(card.r);

        el.innerHTML = `
            <div class="flip-card-inner">
                <div class="card-header">
                    <button class="tts-btn" title="Read Aloud"><i class="fas fa-volume-up"></i></button>
                </div>
                <div class="card-face">${this.md(card.q)}</div>
                <div class="card-face card-back">
                    <div class="response-content">${rhtml}</div>
                </div>
            </div>
        `;

        if (card.styles && Object.keys(card.styles).length > 0) {
            this.updateCardStyles(card.id, card.styles);
        }

        el.querySelector('.tts-btn').onclick = (e) => {
            e.stopPropagation();
            this.readCard(card.id);
        };

        let timer;
        el.ontouchstart = e => {
            if (e.touches.length === 1) timer = setTimeout(() => this.enterSelect(card.id, el), 600);
            if (e.touches.length === 2) {
                e.preventDefault();
                this.currentMenuId = card.id;
                document.getElementById('cardMenu').classList.add('active');
            }
        };
        el.ontouchend = el.ontouchmove = () => clearTimeout(timer);

        el.onclick = e => {
            if (this.selectMode) {
                e.preventDefault();
                this.toggleSelect(card.id, el);
                return;
            }
            el.classList.toggle('flipped');
        };
        el.ondblclick = () => this.openFS(card.id);

        document.getElementById('grid').appendChild(el);
        if (card.r && card.r !== '...') setTimeout(() => el.classList.add('flipped'), 100);
    }

    handle(action) {
        const card = this.cards.find(c => c.id === this.currentMenuId);
        if (!card) return;

        if (action === 'continue') this.promptContinue(card.id);
        if (action === 'copy') navigator.clipboard.writeText(card.r || '');
        if (action === 'ai-edit') this.promptEdit(card.id);
        if (action === 'split') this.promptSplit(card.id);
        if (action === 'fullscreen') this.openFS(card.id);
        if (action === 'delete') if (confirm('Delete this card?')) this.del(card.id);
    }

    readCard(cardId) {
        const card = this.cards.find(c => c.id === cardId);
        if (!card) return;

        const textToRead = card.r || card.q;
        if (responsiveVoice.isPlaying()) {
            responsiveVoice.cancel();
        } else {
            responsiveVoice.speak(this.sanitizeTextForSpeech(textToRead), "US English Female");
        }
    }

    sanitizeTextForSpeech(text) {
        return text
            .replace(/\*\*(.*?)\*\*/g, "$1")
            .replace(/\*(.*?)\*/g, "$1")
            .replace(/`(.*?)`/g, "$1")
            .replace(/``````/g, "Here is the code: $1")
            .replace(/!(bg-color|text-color|border-color|padding|border-radius|font-size|font-weight|font-style|text-decoration|custom-css|page-theme):[^!]+!/gi, "");
    }

    editText(id, field) {
        const card = this.cards.find(c => c.id === id);
        if (!card) return;
        this.editingCardId = id;
        this.editingField = field;
        document.getElementById('textEditorArea').value = field === 'q' ? card.q : card.r;
        document.getElementById('textEditorModal').classList.add('active');
    }

    saveManualEdit() {
        const text = document.getElementById('textEditorArea').value.trim();
        const card = this.cards.find(c => c.id === this.editingCardId);
        if (!card) return;

        if (this.editingField === 'q') {
            card.q = text;
            const qEl = document.querySelector(`[data-id="${this.editingCardId}"] .card-face:first-child`);
            if (qEl) qEl.innerHTML = this.md(text);
            if (this.fullscreenId === this.editingCardId) {
                document.getElementById('fsQuestion').innerHTML = this.md(text);
            }
        } else {
            card.r = text;
            const html = this.md(text);
            const rEl = document.querySelector(`[data-id="${this.editingCardId}"] .response-content`);
            if (rEl) rEl.innerHTML = html;
            if (this.fullscreenId === this.editingCardId) {
                document.getElementById('fsResponse').innerHTML = html;
            }
        }

        this.save();
        document.getElementById('textEditorModal').classList.remove('active');
    }

    promptContinue(id) {
        this.currentContinueId = id;
        document.getElementById('continuePromptText').value = '';
        document.getElementById('continuePromptModal').classList.add('active');
    }

    async continue() {
        const card = this.cards.find(c => c.id === this.currentContinueId);
        if (!card) return;

        const custom = document.getElementById('continuePromptText').value.trim();
        const context = `User request: ${card.q}\n\nPrevious response:\n${card.r || ''}`;
        const prompt = custom
            ? `${context}\n\nAdditional instructions: ${custom}\n\nContinue the response:`
            : `${context}\n\nContinue the response naturally from where it left off:`;

        const id = this.add({ q: `Continued from: ${card.q.slice(0, 30)}...`, r: '...' }, true);
        this.streamingId = id;
        await this.request(prompt);
        document.getElementById('continuePromptModal').classList.remove('active');
    }

    promptSplit(id) {
        this.currentSplitId = id;
        document.getElementById('splitPromptText').value = '';
        document.getElementById('splitPromptModal').classList.add('active');
    }

    async split() {
        const card = this.cards.find(c => c.id === this.currentSplitId);
        if (!card) return;

        const custom = document.getElementById('splitPromptText').value.trim();
        const prompt = custom
            ? `Split the text below according to these instructions: ${custom}\n\nText:\n${card.r}`
            : `Split the following text into clear, logical sections with descriptive titles:\n\n${card.r}`;

        const id = this.add({ q: `Split from: ${card.q.slice(0, 30)}...`, r: '...' }, true);
        this.streamingId = id;
        await this.request(prompt);
        document.getElementById('splitPromptModal').classList.remove('active');
    }

    promptEdit(id) {
        this.currentEditId = id;
        document.getElementById('editPromptText').value = '';
        document.getElementById('editPromptModal').classList.add('active');
    }

    async performEdit() {
        const card = this.cards.find(c => c.id === this.currentEditId);
        if (!card) return;

        const instructions = document.getElementById('editPromptText').value.trim() || 'Improve clarity, flow, and structure';
        const prompt = `Original request: ${card.q}\n\nCurrent response:\n${card.r || ''}\n\nInstructions: ${instructions}\n\nOutput only the revised response:`;

        const id = this.add({ q: `Edited: ${card.q.slice(0, 30)}...`, r: '...' }, true);
        this.streamingId = id;
        await this.request(prompt);
        document.getElementById('editPromptModal').classList.remove('active');
    }

    merge() {
        if (this.selected.size < 2) return;

        const sel = Array.from(this.selected).map(id => this.cards.find(c => c.id === id));
        const content = sel.map(c => c.r || '').join('\n\n');
        const custom = document.getElementById('mergePromptText').value.trim();

        let prompt;
        if (custom) {
            prompt = `Merge the following texts into one cohesive response based on these instructions: ${custom}

Texts to merge:
${content}

Merged response (output only the final content):`;
        } else {
            prompt = `The following are multiple response drafts. Combine them into one single, coherent, well-written response. Keep all key details and improve the overall flow.

Drafts:
${content}

Final merged response (output only the content):`;
        }

        const id = this.add({ q: `Merged ${sel.length} cards`, r: '...' }, true);
        this.streamingId = id;
        this.request(prompt);
        document.getElementById('mergePromptModal').classList.remove('active');
        this.exitSelect();
    }

    openFS(id, back = false) {
        const card = this.cards.find(c => c.id === id);
        if (!card) return;

        document.getElementById('fsQuestion').innerHTML = this.md(card.q);
        const responseEl = document.getElementById('fsResponse');
        const baseHtml = (card.r && card.r !== '...') ? this.md(card.r) : '<div class="streaming"><span class="cursor"></span></div>';
        responseEl.innerHTML = baseHtml + (this.streamingId === id ? '<div class="streaming"><span class="cursor"></span></div>' : '');

        const ov = document.getElementById('fullscreenOverlay');
        ov.classList.add('active');
        if (back) ov.classList.add('flipped');
        else ov.classList.remove('flipped');
        this.fullscreenId = id;
        document.body.style.overflow = 'hidden';
    }

    closeFS() {
        document.getElementById('fullscreenOverlay').classList.remove('active', 'flipped');
        this.fullscreenId = null;
        document.body.style.overflow = '';
    }

    del(id) {
        this.cards = this.cards.filter(c => c.id !== id);
        document.querySelector(`[data-id="${id}"]`)?.remove();
        if (this.fullscreenId === id) this.closeFS();
        this.save();
    }

    enterSelect(id, el) {
        this.selectMode = true;
        this.selected.clear();
        this.toggleSelect(id, el);
    }

    toggleSelect(id, el) {
        el.classList.toggle('selected');
        if (this.selected.has(id)) this.selected.delete(id);
        else this.selected.add(id);

        document.getElementById('selectCount').textContent = this.selected.size;
        document.getElementById('mergeSelected').style.display = this.selected.size >= 2 ? 'block' : 'none';
        document.getElementById('selectionBar').classList.toggle('active', this.selected.size > 0);
    }

    exitSelect() {
        this.selectMode = false;
        this.selected.clear();
        document.querySelectorAll('.flip-card.selected').forEach(e => e.classList.remove('selected'));
        document.getElementById('selectionBar').classList.remove('active');
    }

    export() {
        const data = { cards: this.cards, sessionId: this.sessionId, theme: this.theme };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'parametric-cards.json';
        a.click();
        URL.revokeObjectURL(url);
    }

    import(e) {
        const file = e.target.files[0];
        if (!file) return;
        const r = new FileReader();
        r.onload = ev => {
            try {
                const d = JSON.parse(ev.target.result);
                this.cards = d.cards || [];
                this.sessionId = d.sessionId || this.sessionId;
                this.theme = d.theme || { ...DEFAULT_THEME };
                document.getElementById('grid').innerHTML = '';
                this.applyTheme(this.theme);
                this.cards.forEach(c => this.render(c));
                this.save();
            } catch (err) {
                alert('Import failed');
            }
        };
        r.readAsText(file);
    }

    save() {
        localStorage.setItem('data', JSON.stringify({
            cards: this.cards,
            sessionId: this.sessionId,
            theme: this.theme
        }));
    }

    load() {
        const raw = localStorage.getItem('data');
        if (raw) {
            try {
                const d = JSON.parse(raw);
                this.cards = d.cards || [];
                this.sessionId = d.sessionId || this.sessionId;
                this.theme = d.theme || { ...DEFAULT_THEME };
                this.cards.forEach(c => this.render(c));
            } catch (err) {
                console.error('Load failed:', err);
            }
        }
    }

    md(t) {
        return t ? DOMPurify.sanitize(marked.parse(t)) : '';
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    const autoReadBtn = document.getElementById('toggleTTSBtn');
    autoReadBtn.style.opacity = app.autoReadEnabled ? '1' : '0.5';
});
</script>

</body>
</html>